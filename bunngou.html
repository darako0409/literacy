<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>力の分解と合成 シミュレータ (テキスト表示切替機能付き)</title>
<style>
    body { font-family: sans-serif; display: flex; flex-direction: column; align-items: center; margin: 20px; background-color: #f0f2f5; color: #333; }
    #controls { margin-bottom: 20px; padding: 20px; background-color: #ffffff; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.1); width: clamp(400px, 90%, 800px); }
    label { margin-right: 10px; font-weight: bold; font-size: 22px; }
    input[type="number"], input[type="range"] { margin-right: 15px; padding: 8px; border-radius: 4px; border: 1px solid #ccc; box-sizing: border-box; font-size: 20px; }
    input[type="number"] { width: 100px; }
    input[type="range"] { width: calc(100% - 250px); vertical-align: middle; }
    button#toggleTextButton { padding: 10px 15px; font-size: 18px; border-radius: 4px; border: 1px solid #007bff; background-color: #007bff; color: white; cursor: pointer; margin-top: 10px;}
    button#toggleTextButton:hover { background-color: #0056b3; }
    canvas { border: 1px solid #b0b0b0; background-color: #fdfdfd; margin-top: 10px; border-radius: 8px; display: block; margin-left: auto; margin-right: auto; }
    #results { margin-top: 20px; font-size: 22px; padding: 15px; background-color: #e6f7ff; border-radius: 8px; border: 1px solid #91d5ff; width: clamp(400px, 90%, 800px); }
    .control-group { margin-bottom: 15px; display: flex; align-items: center; flex-wrap: wrap; }
    .control-group label { min-width: 220px; }
    #angleValueDisplay { font-weight: bold; color: #007bff; margin-left: 5px; font-size: 22px;}
    #tensionValue, #resultantForceValue { font-weight: bold; color: #28a745; }
    h1 { color: #0056b3; text-align: center; font-size: 36px;}
    p { line-height: 1.6; text-align: center; max-width: 800px; margin-left: auto; margin-right: auto; font-size: 18px;}

    @media (max-width: 700px) {
        #controls, #results { width: 95%; }
        input[type="range"] { width: calc(100% - 150px); }
        .control-group label { min-width: 150px; margin-bottom: 5px;}
        .control-group { flex-direction: column; align-items: flex-start; }
        input[type="number"], input[type="range"], span#angleValueDisplay, button#toggleTextButton { margin-bottom: 10px; }
        h1 { font-size: 28px; }
        label, input, #angleValueDisplay, #results, button#toggleTextButton { font-size: 18px; }
    }
</style>
</head>
<body>

<h1>力の分解と合成 シミュレータ</h1>
<p>2本のひもで物体を支えるとき、ひもの間の角度によって各ひもにかかる力がどう変わるかを見てみましょう。</p>

<div id="controls">
    <div class="control-group">
        <label for="weight">物体の重さ (W):</label>
        <input type="number" id="weight" value="100" min="10" max="500" step="5"> N
    </div>
    <div class="control-group">
        <label for="angle">2本のひもの間の角度 (θ):</label>
        <input type="range" id="angle" min="0" max="178" value="60" step="1">
        <span id="angleValueDisplay">60</span> °
    </div>
    <div class="control-group"> <button id="toggleTextButton">テキストを非表示</button>
    </div>
</div>

<canvas id="physicsCanvas" width="800" height="650"></canvas>
<div id="results">
    <p>各ひもにかかる張力 (T): <span id="tensionValue">N/A</span> N</p>
    <p>合力 (上向きの力の合計): <span id="resultantForceValue">N/A</span> N (これは物体の重さとつり合います)</p>
</div>

<script>
    // DOM Elements
    const canvas = document.getElementById('physicsCanvas');
    const ctx = canvas.getContext('2d');
    const weightInput = document.getElementById('weight');
    const angleInput = document.getElementById('angle');
    const angleValueDisplay = document.getElementById('angleValueDisplay');
    const tensionValueDisplay = document.getElementById('tensionValue');
    const resultantForceValueDisplay = document.getElementById('resultantForceValue');
    const toggleTextButton = document.getElementById('toggleTextButton'); // ボタンを取得

    // Simulation Constants
    const objectRadius = 25;
    let objectX = canvas.width / 2;
    let objectY = canvas.height / 2.7;
    let stringLengthVisual = Math.min(canvas.width, canvas.height) / 3.2;
    const forceVectorScale = 1.0;
    const baseFontSize = 24;

    let showText = true; // ★ テキスト表示状態を管理する変数

    // Helper function to draw an arrow
    function drawArrow(x1, y1, x2, y2, color = 'black', lineWidth = 2, label = '', labelXOffset = 0, labelYOffset = 0, labelAtTip = false) {
        ctx.beginPath();
        ctx.strokeStyle = color;
        ctx.fillStyle = color;
        ctx.lineWidth = lineWidth;
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
        
        const headlen = 15;
        const angle = Math.atan2(y2 - y1, x2 - x1);
        ctx.lineTo(x2 - headlen * Math.cos(angle - Math.PI / 6), y2 - headlen * Math.sin(angle - Math.PI / 6));
        ctx.moveTo(x2, y2);
        ctx.lineTo(x2 - headlen * Math.cos(angle + Math.PI / 6), y2 - headlen * Math.sin(angle + Math.PI / 6));
        ctx.stroke();

        if (label && showText) { // ★ showTextがtrueの場合のみラベルを描画
            ctx.font = `${baseFontSize}px Arial`;
            ctx.textAlign = 'left';

            let textX, textY;
            if (labelAtTip) {
                textX = x2 + labelXOffset;
                textY = y2 + labelYOffset;
                if (Math.abs(x2 - x1) < 1) { 
                    textX = x2 + (labelXOffset || 10); 
                    textY = y2 + (y2 < y1 ? -baseFontSize*0.5 : baseFontSize*0.8) + labelYOffset;
                } else if (Math.abs(y2 - y1) < 1) { 
                    textX = x2 + (x2 < x1 ? -ctx.measureText(label).width -10 : 10) + labelXOffset;
                    textY = y2 + (labelYOffset || -baseFontSize*0.3);
                } else { 
                     textX = x2 + (x2 < x1 ? -ctx.measureText(label).width -10 : 10) + labelXOffset;
                     textY = y2 + (y2 < y1 ? -baseFontSize*0.5 : baseFontSize*0.8) + labelYOffset;
                }
            } else { 
                textX = (x1 + x2) / 2 + labelXOffset;
                textY = (y1 + y2) / 2 + labelYOffset;
                 if (x1 === x2) { 
                    textX = x2 + labelXOffset; 
                    textY = (y1 + y2) / 2 + labelYOffset;
                } else if (y1 === y2) { 
                    textY = y2 + labelYOffset - 15; 
                } else { 
                     if (x2 < x1) textX -= 10; else textX += 10; 
                     if (y2 < y1) textY -= 5; else textY += 5;   
                }
            }
            
            textX = Math.max(10, Math.min(canvas.width - ctx.measureText(label).width - 10, textX));
            textY = Math.max(baseFontSize, Math.min(canvas.height - 10, textY));

            ctx.fillText(label, textX, textY);
        }
    }

    // Main drawing function
    function drawSimulation() {
        const W = parseFloat(weightInput.value);
        const totalAngleDeg = parseFloat(angleInput.value);
        angleValueDisplay.textContent = totalAngleDeg;

        const betaDeg = totalAngleDeg / 2; 
        const betaRad = betaDeg * Math.PI / 180;

        let T = 0;
        let resultantForceY_magnitude = 0; 
        const cosBeta = Math.cos(betaRad);

        if (Math.abs(cosBeta) < 0.001) { 
            T = Infinity; 
            resultantForceY_magnitude = W; 
        } else {
            T = W / (2 * cosBeta);
            resultantForceY_magnitude = 2 * T * cosBeta; 
        }
        
        tensionValueDisplay.textContent = T === Infinity ? "∞ (ほぼ水平)" : T.toFixed(2);
        resultantForceValueDisplay.textContent = resultantForceY_magnitude.toFixed(2);

        ctx.clearRect(0, 0, canvas.width, canvas.height);

        objectX = canvas.width / 2;
        objectY = canvas.height / 2.7; 
        stringLengthVisual = Math.min(canvas.width, canvas.height) / 3.2;

        const forceOriginX = objectX;
        const forceOriginY = objectY - objectRadius; 

        ctx.beginPath();
        ctx.arc(objectX, objectY, objectRadius, 0, 2 * Math.PI);
        ctx.fillStyle = 'skyblue';
        ctx.fill();
        ctx.strokeStyle = 'blue';
        ctx.lineWidth = 3;
        ctx.stroke();
        
        // 重力ベクトルを描画
        const weightVectorLength = Math.min(canvas.height / 6, W * forceVectorScale * 0.4);
        const weightVectorEndY = objectY + weightVectorLength; 
        drawArrow(objectX, objectY, objectX, weightVectorEndY, 'red', 4);

        // ★ テキスト描画をshowTextで制御
        if (showText) {
            ctx.fillStyle = 'black';
            ctx.textAlign = 'center';
            ctx.font = `${baseFontSize}px Arial`;
            const weightValueTextY = weightVectorEndY + baseFontSize + 5;
            ctx.fillText(`W=${W.toFixed(0)}N`, objectX, weightValueTextY);

            ctx.fillStyle = 'red';
            ctx.textAlign = 'left'; 
            ctx.font = `${baseFontSize}px Arial`;
            const gravityLabelX = objectX + 20; 
            const gravityLabelY = objectY + weightVectorLength / 2 + baseFontSize / 3; 
            ctx.fillText(`重力 W`, gravityLabelX, gravityLabelY);
        }


        // ひもの描画
        const endX1_string_visual = forceOriginX - stringLengthVisual * Math.sin(betaRad);
        const endY1_string_visual = forceOriginY - stringLengthVisual * Math.cos(betaRad);
        const endX2_string_visual = forceOriginX + stringLengthVisual * Math.sin(betaRad);
        const endY2_string_visual = forceOriginY - stringLengthVisual * Math.cos(betaRad);

        ctx.beginPath();
        ctx.strokeStyle = 'dimgray';
        ctx.lineWidth = 3;
        ctx.moveTo(forceOriginX, forceOriginY);
        ctx.lineTo(endX1_string_visual, endY1_string_visual);
        ctx.moveTo(forceOriginX, forceOriginY);
        ctx.lineTo(endX2_string_visual, endY2_string_visual);
        ctx.stroke();

        const tensionVectorDisplayLength = Math.min(stringLengthVisual * 0.95, T * forceVectorScale * 0.4);
        const tension1AngleVisualRad = (3 * Math.PI / 2) - betaRad; 
        const tension2AngleVisualRad = (3 * Math.PI / 2) + betaRad; 
        
        if (T !== Infinity && T > 0) {
            const tension1EndX = forceOriginX + tensionVectorDisplayLength * Math.cos(tension1AngleVisualRad);
            const tension1EndY = forceOriginY + tensionVectorDisplayLength * Math.sin(tension1AngleVisualRad);
            // drawArrow内でshowTextがチェックされる
            drawArrow(forceOriginX, forceOriginY, tension1EndX, tension1EndY, 'green', 4, `ひも1=${T.toFixed(1)}N`, 5, -baseFontSize*0.7, true);

            const tension2EndX = forceOriginX + tensionVectorDisplayLength * Math.cos(tension2AngleVisualRad);
            const tension2EndY = forceOriginY + tensionVectorDisplayLength * Math.sin(tension2AngleVisualRad);
            // drawArrow内でshowTextがチェックされる
            drawArrow(forceOriginX, forceOriginY, tension2EndX, tension2EndY, 'green', 4, `ひも2=${T.toFixed(1)}N`, 5, -baseFontSize*0.7, true);

            const resultantVectorDisplayLength = Math.min(stringLengthVisual * 1.1, resultantForceY_magnitude * forceVectorScale * 0.4);
            const resultantTipX = forceOriginX; 
            const resultantTipY = forceOriginY - resultantVectorDisplayLength;

            ctx.beginPath();
            ctx.strokeStyle = 'rgba(0, 0, 255, 0.4)';
            ctx.lineWidth = 1.5;
            ctx.setLineDash([4, 4]);
            ctx.moveTo(tension1EndX, tension1EndY); 
            ctx.lineTo(resultantTipX, resultantTipY); 
            ctx.moveTo(tension2EndX, tension2EndY); 
            ctx.lineTo(resultantTipX, resultantTipY); 
            ctx.stroke();
            ctx.setLineDash([]);

            drawArrow(forceOriginX, forceOriginY, resultantTipX, resultantTipY, 'blue', 4);
            // ★ テキスト描画をshowTextで制御
            if (showText) {
                ctx.fillStyle = 'blue';
                ctx.textAlign = 'center';
                ctx.font = `${baseFontSize}px Arial`;
                ctx.fillText(`合力R=${resultantForceY_magnitude.toFixed(1)}N`, resultantTipX, resultantTipY - baseFontSize * 1.0 - 15);
            }
        }
        
        if (totalAngleDeg > 1 && totalAngleDeg < 179) { 
            ctx.beginPath();
            ctx.strokeStyle = 'magenta'; 
            ctx.lineWidth = 2;
            const arcRadiusTheta = stringLengthVisual * 0.2;

            const string1ActualAngle = -Math.PI / 2 - betaRad;
            const string2ActualAngle = -Math.PI / 2 + betaRad;
            
            ctx.arc(forceOriginX, forceOriginY, arcRadiusTheta, string1ActualAngle, string2ActualAngle, false);
            ctx.stroke();

            // ★ テキスト描画をshowTextで制御
            if (showText) {
                ctx.fillStyle = 'magenta';
                ctx.font = `${baseFontSize - 4}px Arial`;
                ctx.textAlign = 'center';
                
                const midAngleForText = -Math.PI / 2;
                const textRadiusForTheta = arcRadiusTheta + baseFontSize * 0.6;

                let textThetaX = forceOriginX + textRadiusForTheta * Math.cos(midAngleForText);
                let textThetaY = forceOriginY + textRadiusForTheta * Math.sin(midAngleForText);
                textThetaY += baseFontSize * 0.3; 

                if (totalAngleDeg < 45) {
                    textThetaY -= baseFontSize * 0.4;
                }
                ctx.fillText(`${totalAngleDeg.toFixed(0)}°`, textThetaX, textThetaY);
            }
        }
    }

    // Event Listeners
    weightInput.addEventListener('input', drawSimulation);
    angleInput.addEventListener('input', drawSimulation);

    // ★ ボタンのイベントリスナー
    toggleTextButton.addEventListener('click', function() {
        showText = !showText; // 表示状態を反転
        if (showText) {
            toggleTextButton.textContent = 'テキストを非表示';
        } else {
            toggleTextButton.textContent = 'テキストを表示';
        }
        drawSimulation(); // 再描画して変更を反映
    });

    drawSimulation();
</script>

</body>
</html>
