<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>立体切断シミュレーター v9 (タブ構成版)</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: "Helvetica Neue", Arial, sans-serif; background-color: #f0f0f0; }
        #canvas-container { width: 100vw; height: 100vh; position: relative; }
        
        /* 頂点ラベル */
        .vertex-label {
            position: absolute;
            background: rgba(255, 255, 255, 0.85);
            border: 1px solid #333;
            border-radius: 50%;
            width: 20px; height: 20px;
            text-align: center; line-height: 20px;
            font-size: 12px; font-weight: bold; color: #000;
            pointer-events: none;
            z-index: 5;
            transform: translate(-50%, -50%);
            display: none; 
        }

        /* UIパネル */
        #ui-panel {
            position: absolute; top: 10px; left: 10px;
            width: 340px; background: rgba(255, 255, 255, 0.95);
            padding: 15px; border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.15);
            max-height: 85vh; overflow-y: auto;
            z-index: 10;
            font-size: 14px;
        }
        @media (max-width: 600px) {
            #ui-panel { width: 90%; left: 5%; top: 10px; max-height: 60vh; }
        }

        h2 { margin-top: 0; font-size: 18px; color: #333; border-bottom: 2px solid #007bff; padding-bottom: 8px; margin-bottom: 15px;}
        
        /* タブ */
        .tab-container { display: flex; margin-bottom: 15px; border-bottom: 1px solid #ddd; }
        .tab-btn {
            flex: 1; padding: 8px 4px; text-align: center; cursor: pointer;
            background: #f8f9fa; border: 1px solid #ddd; border-bottom: none;
            margin-right: 2px; border-radius: 4px 4px 0 0; color: #666; font-size: 12px; white-space: nowrap;
        }
        .tab-btn.active { background: #fff; font-weight: bold; color: #007bff; border-bottom: 2px solid #fff; margin-bottom: -1px; }
        
        .mode-content { display: none; }
        .mode-content.active { display: block; }

        .control-group { margin-bottom: 15px; padding-bottom: 10px; border-bottom: 1px solid #eee; }
        .control-group:last-child { border-bottom: none; }
        
        label { display: block; margin-bottom: 5px; font-weight: bold; color: #444; cursor: pointer; }
        .checkbox-label { font-weight: normal; display: flex; align-items: center; gap: 5px; margin-bottom: 5px; }

        button {
            width: 100%; padding: 10px; margin-bottom: 8px;
            background-color: #007bff; color: white; border: none;
            border-radius: 4px; cursor: pointer; transition: background 0.2s;
        }
        button:hover { background-color: #0056b3; }
        button.secondary { background-color: #6c757d; }
        button.secondary:hover { background-color: #545b62; }
        button.danger { background-color: #dc3545; }
        button:disabled { background-color: #ccc; cursor: not-allowed; opacity: 0.7; }
        
        select { width: 100%; padding: 8px; border-radius: 4px; border: 1px solid #ccc; }
        input[type=range] { width: 100%; cursor: pointer; }
        .value-display { float: right; font-weight: normal; font-family: monospace; }
        .hint-text { font-size: 12px; color: #666; margin-top: -2px; margin-bottom: 8px; line-height: 1.4; }
        
        /* ARボタンのスタイル上書き（初期は非表示） */
        #ar-button-container { display: none; } 

        #error-log {
            position: absolute; bottom: 10px; left: 10px;
            background: rgba(200, 0, 0, 0.9); color: white;
            padding: 10px; border-radius: 5px; font-size: 12px;
            max-width: 400px; display: none; pointer-events: none; z-index: 999;
        }
    </style>
</head>
<body>

<div id="canvas-container">
    <div id="labels-container"></div>
</div>

<div id="error-log"></div>

<div id="ui-panel">
    <h2>立体切断シミュレーター v9</h2>

    <div class="control-group">
        <label>図形選択</label>
        <select id="shape-select">
            <option value="cube">立方体</option>
            <option value="prism">正四角柱</option>
            <option value="pyramid">正四角錐</option>
            <option value="tri_pyramid">正三角錐</option>
            <option value="cylinder">円柱</option>
        </select>
        <button id="reset-btn" class="secondary" style="margin-top:5px; padding:6px;">図形をリセット</button>
    </div>

    <div class="tab-container">
        <div class="tab-btn active" onclick="switchMode('slider')">① スライダー</div>
        <div class="tab-btn" onclick="switchMode('points')">② 点指定</div>
        <div class="tab-btn" onclick="switchMode('ar')">③ ARで確認</div>
    </div>

    <div id="mode-slider" class="mode-content active">
        <div id="slider-controls-wrapper">
            <div class="control-group">
                <label>切断面の調整</label>
                <label>高さ (Y) <span id="val-y" class="value-display">0.00</span></label>
                <input type="range" id="cut-y" min="-3" max="3" step="0.01" value="0">
                <label>回転 (X:手前奥) <span id="val-rx" class="value-display">0°</span></label>
                <input type="range" id="cut-rx" min="-180" max="180" step="1" value="0">
                <label>回転 (Z:左右) <span id="val-rz" class="value-display">0°</span></label>
                <input type="range" id="cut-rz" min="-180" max="180" step="1" value="0">
                <button class="secondary" id="reset-slider-btn" style="font-size:12px; padding:5px; margin-top:5px;">角度を水平に戻す</button>
            </div>
        </div>
    </div>

    <div id="mode-points" class="mode-content">
        <div class="control-group">
            <label>切断点の選択</label>
            <p class="hint-text">● <b>頂点</b> (大) / ● <b>中点・3等分点</b> (小)</p>
            <div style="display:flex; gap:5px;">
                <button id="clear-points-btn" class="danger" style="font-size:12px;">選択クリア</button>
            </div>
            <p id="points-count-display" style="font-weight:bold; color:#007bff; margin:5px 0;">選択数: 0点</p>
        </div>
    </div>

    <div id="mode-ar" class="mode-content">
        <div class="control-group">
            <label>AR（拡張現実）モード</label>
            <p class="hint-text">
                作成した図形を、スマホのカメラ越しに机の上などに表示できます。<br><br>
                1. 下の <b>[START AR]</b> ボタンを押す<br>
                2. カメラで床や机を映す<br>
                3. 白いリングが出たら画面をタップ
            </p>
            <p style="font-size:12px; color:#d63384;">※この機能はAR対応スマホでのみ動作します。</p>
        </div>
    </div>

    <div class="control-group">
        <label>切断実行</label>
        <button id="cut-btn">✂️ 切断 (基本)</button>
        <button id="cut-btn-inverse">✂️ 切断 (逆側を残す)</button>
    </div>

    <div class="control-group">
        <button id="undo-btn" class="secondary" disabled>↩️ ひとつ戻る (Undo)</button>
        
        <div style="margin-top:15px; padding-top:10px; border-top:1px solid #ddd;">
             <label style="font-size:12px; margin-bottom:8px; color:#666;">▼ 表示オプション</label>
             <label class="checkbox-label"><input type="checkbox" id="wireframe-check"> ワイヤーフレームのみ</label>
             <label class="checkbox-label"><input type="checkbox" id="grid-visible-check" checked> グリッド・軸を表示</label>
             <label class="checkbox-label"><input type="checkbox" id="labels-visible-check" checked> 頂点ラベル(A,B..)を表示</label>
             <hr style="border:0; border-top:1px dashed #eee; margin:5px 0;">
             <label class="checkbox-label"><input type="checkbox" id="plane-visible-check" checked> 青い切断面を表示</label>
             <label class="checkbox-label"><input type="checkbox" id="slider-visible-check" checked> スライダー操作パネルを表示</label>
        </div>
    </div>
</div>

<script type="importmap">
    {
        "imports": {
            "three": "https://esm.sh/three@0.160.0",
            "three/addons/": "https://esm.sh/three@0.160.0/examples/jsm/",
            "three-bvh-csg": "https://esm.sh/three-bvh-csg@0.0.16?deps=three@0.160.0"
        }
    }
</script>

<script type="module">
    // エラー処理
    window.onerror = function(message, source, lineno, colno, error) {
        const el = document.getElementById('error-log');
        el.style.display = 'block';
        el.innerHTML += `Error: ${message}<br><small>${source}:${lineno}</small><br>`;
    };

    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { ARButton } from 'three/addons/webxr/ARButton.js';
    import { SUBTRACTION, Brush, Evaluator } from 'three-bvh-csg';

    // --- 1. シーン設定 ---
    const container = document.getElementById('canvas-container');
    const labelsContainer = document.getElementById('labels-container');
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xfafafa);

    const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
    camera.position.set(6, 5, 8);

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    renderer.xr.enabled = true; 
    container.appendChild(renderer.domElement);

    // ARボタンの作成 (初期状態はCSSで非表示にするため、スタイル制御用の変数に入れる)
    const arButton = ARButton.createButton(renderer, { 
        requiredFeatures: ['hit-test'],
        optionalFeatures: ['dom-overlay'],
        domOverlay: { root: document.getElementById('ui-panel') } 
    });
    document.body.appendChild(arButton);
    // ARボタンを初期状態で隠す
    arButton.style.display = 'none'; 

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;

    // ライト
    const ambientLight = new THREE.AmbientLight(0xffffff, 2.5); 
    scene.add(ambientLight);
    const dirLight = new THREE.DirectionalLight(0xffffff, 0.5);
    dirLight.position.set(5, 10, 7);
    dirLight.castShadow = true;
    scene.add(dirLight);
    const fillLight = new THREE.DirectionalLight(0xffffff, 0.5);
    fillLight.position.set(-5, 0, -5);
    scene.add(fillLight);

    // --- グローバル変数 ---
    let contentGroup = new THREE.Group();
    scene.add(contentGroup);

    let currentShapeBrush;    
    let materialStandard;     
    let historyStack = [];    
    
    let cutterGroup;
    let visualPlane;
    let invisibleCutterBrush;

    let currentMode = 'slider'; 
    let interactionObjects = []; 
    let selectedPoints = [];     
    let pointMarkers = [];       
    let raycaster = new THREE.Raycaster();
    let mouse = new THREE.Vector2();
    let hoveredObject = null;    
    
    let helperGroup = new THREE.Group();
    contentGroup.add(helperGroup);

    let vertexLabels = []; 
    let gridHelper, axesHelper;
    const evaluator = new Evaluator();

    // AR用ヒットテスト
    let reticle;
    let hitTestSource = null;
    let hitTestSourceRequested = false;

    materialStandard = new THREE.MeshStandardMaterial({ 
        color: 0x66ccff, 
        roughness: 0.5,
        metalness: 0.0,
        transparent: true,
        opacity: 0.9, 
        side: THREE.DoubleSide,
    });

    // --- 初期化 ---
    init();

    function init() {
        try {
            gridHelper = new THREE.GridHelper(20, 20, 0xcccccc, 0xe5e5e5);
            contentGroup.add(gridHelper);
            
            axesHelper = new THREE.AxesHelper(5);
            contentGroup.add(axesHelper);

            setupCutterSystem();
            createShape('cube');
            updateCutterTransform();

            // レティクル
            reticle = new THREE.Mesh(
                new THREE.RingGeometry(0.15, 0.2, 32).rotateX(-Math.PI / 2),
                new THREE.MeshBasicMaterial({ color: 0xffffff })
            );
            reticle.matrixAutoUpdate = false;
            reticle.visible = false;
            scene.add(reticle); 

            window.addEventListener('resize', onWindowResize);
            renderer.domElement.addEventListener('pointermove', onPointerMove); 
            renderer.domElement.addEventListener('pointerdown', onPointerDown); 
            
            renderer.xr.addEventListener('sessionstart', onSessionStart);
            renderer.xr.addEventListener('sessionend', onSessionEnd);

            renderer.setAnimationLoop(render); 
        } catch (e) {
            console.error(e);
        }
    }

    function onSessionStart() {
        contentGroup.scale.set(0.05, 0.05, 0.05);
        scene.background = null; 
    }

    function onSessionEnd() {
        contentGroup.scale.set(1, 1, 1);
        contentGroup.position.set(0, 0, 0);
        contentGroup.rotation.set(0, 0, 0);
        scene.background = new THREE.Color(0xfafafa);
        reticle.visible = false;
        hitTestSource = null;
        hitTestSourceRequested = false;
    }

    function setupCutterSystem() {
        cutterGroup = new THREE.Group();
        contentGroup.add(cutterGroup); 

        const planeGeo = new THREE.PlaneGeometry(12, 12);
        const planeMat = new THREE.MeshBasicMaterial({
            color: 0x007bff, opacity: 0.2, transparent: true, side: THREE.DoubleSide, depthWrite: false
        });
        visualPlane = new THREE.Mesh(planeGeo, planeMat);
        visualPlane.rotation.x = -Math.PI / 2;
        
        const edges = new THREE.EdgesGeometry(planeGeo);
        const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0x0000ff, opacity: 0.3, transparent:true }));
        visualPlane.add(line);
        cutterGroup.add(visualPlane);

        const boxSize = 30;
        const boxGeo = new THREE.BoxGeometry(boxSize, boxSize, boxSize);
        boxGeo.translate(0, boxSize / 2, 0); 
        invisibleCutterBrush = new Brush(boxGeo, new THREE.MeshBasicMaterial({ visible: false }));
        cutterGroup.add(invisibleCutterBrush);
    }

    function createShape(type) {
        let geometry;
        switch(type) {
            case 'cube': geometry = new THREE.BoxGeometry(3, 3, 3); break;
            case 'prism': geometry = new THREE.BoxGeometry(2, 4, 2); break;
            case 'pyramid': geometry = new THREE.ConeGeometry(2, 3.5, 4); break;
            case 'tri_pyramid': geometry = new THREE.ConeGeometry(2, 3.5, 3); break;
            case 'cylinder': geometry = new THREE.CylinderGeometry(1.5, 1.5, 4, 32); break;
        }

        if (currentShapeBrush) contentGroup.remove(currentShapeBrush);
        
        currentShapeBrush = new Brush(geometry, materialStandard);
        currentShapeBrush.castShadow = true;
        currentShapeBrush.receiveShadow = true;
        contentGroup.add(currentShapeBrush);
        
        historyStack = [];
        createSnapPoints(geometry, currentShapeBrush);
        createLabels(geometry, currentShapeBrush); 
        updateUI();
    }

    function createLabels(geometry, mesh) {
        vertexLabels.forEach(l => l.element.remove());
        vertexLabels = [];
        if (!document.getElementById('labels-visible-check').checked) return;
        const posAttr = geometry.attributes.position;
        const uniquePoints = [];
        const threshold = 0.01;
        for (let i = 0; i < posAttr.count; i++) {
            const v = new THREE.Vector3().fromBufferAttribute(posAttr, i);
            let exists = false;
            for (let p of uniquePoints) {
                if (p.distanceTo(v) < threshold) { exists = true; break; }
            }
            if (!exists) uniquePoints.push(v);
        }
        uniquePoints.sort((a, b) => {
            if (Math.abs(b.y - a.y) > 0.1) return b.y - a.y; 
            if (Math.abs(b.x - a.x) > 0.1) return a.x - b.x; 
            return a.z - b.z;
        });
        const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
        uniquePoints.forEach((localPos, index) => {
            if (index >= chars.length) return;
            const labelText = chars[index];
            const div = document.createElement('div');
            div.className = 'vertex-label';
            div.innerText = labelText;
            labelsContainer.appendChild(div);
            vertexLabels.push({ element: div, localPos: localPos.clone(), mesh: mesh });
        });
    }

    function updateLabels() {
        if (vertexLabels.length === 0) return;
        const isVisible = document.getElementById('labels-visible-check').checked;
        if (!isVisible) {
             vertexLabels.forEach(l => l.element.style.display = 'none');
             return;
        }
        const widthHalf = window.innerWidth / 2;
        const heightHalf = window.innerHeight / 2;

        vertexLabels.forEach(label => {
            const worldPos = label.localPos.clone().applyMatrix4(label.mesh.matrixWorld);
            const pos = worldPos.clone();
            pos.project(camera);

            if (pos.z > 1) {
                label.element.style.display = 'none';
            } else {
                label.element.style.display = 'block';
                const x = (pos.x * widthHalf) + widthHalf;
                const y = -(pos.y * heightHalf) + heightHalf;
                label.element.style.left = `${x}px`;
                label.element.style.top = `${y}px`;
            }
        });
    }

    function createSnapPoints(geometry, mesh) {
        helperGroup.clear();
        interactionObjects = [];
        const addedPoints = new Set(); 
        function addSnapSphere(pos, type) {
            const key = `${pos.x.toFixed(3)},${pos.y.toFixed(3)},${pos.z.toFixed(3)}`;
            if (addedPoints.has(key)) return;
            addedPoints.add(key);
            const size = (type === 'vertex') ? 0.15 : 0.08;
            const color = (type === 'vertex') ? 0x333333 : 0x666666;
            const opacity = (type === 'vertex') ? 0.6 : 0.4;
            const geo = new THREE.SphereGeometry(size, 16, 16);
            const mat = new THREE.MeshBasicMaterial({ color: color, transparent: true, opacity: opacity });
            const sphere = new THREE.Mesh(geo, mat);
            sphere.position.copy(pos);
            sphere.userData = { isSnapPoint: true, originalColor: color, hoverColor: 0xffaa00, pos: pos.clone() };
            helperGroup.add(sphere);
            interactionObjects.push(sphere);
        }
        const posAttr = geometry.attributes.position;
        for(let i=0; i<posAttr.count; i++){
             addSnapSphere(new THREE.Vector3().fromBufferAttribute(posAttr, i), 'vertex');
        }
        const edgesGeo = new THREE.EdgesGeometry(geometry, 20); 
        const edgePos = edgesGeo.attributes.position;
        for (let i = 0; i < edgePos.count; i += 2) {
            const start = new THREE.Vector3().fromBufferAttribute(edgePos, i);
            const end = new THREE.Vector3().fromBufferAttribute(edgePos, i + 1);
            addSnapSphere(start.clone().lerp(end, 0.5), 'sub');
            addSnapSphere(start.clone().lerp(end, 1/3), 'sub');
            addSnapSphere(start.clone().lerp(end, 2/3), 'sub');
        }
    }

    function onPointerMove(event) {
        if (currentMode !== 'points') return;
        if (renderer.xr.isPresenting) return; 
        updateMouse(event);
        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects(interactionObjects);
        if (intersects.length > 0) {
            const obj = intersects[0].object;
            if (hoveredObject !== obj) {
                if (hoveredObject) hoveredObject.material.color.setHex(hoveredObject.userData.originalColor);
                hoveredObject = obj;
                hoveredObject.material.color.setHex(obj.userData.hoverColor);
                document.body.style.cursor = 'pointer';
            }
        } else {
            if (hoveredObject) {
                hoveredObject.material.color.setHex(hoveredObject.userData.originalColor);
                hoveredObject = null;
                document.body.style.cursor = 'default';
            }
        }
    }

    function onSelect() {
        if (reticle.visible) {
            reticle.matrix.decompose(contentGroup.position, contentGroup.quaternion, contentGroup.scale);
            contentGroup.scale.set(0.05, 0.05, 0.05); 
        }
    }
    const controller = renderer.xr.getController(0);
    controller.addEventListener('select', onSelect);
    scene.add(controller);

    function onPointerDown(event) {
        if (!renderer.xr.isPresenting && currentMode === 'points') {
            if (!hoveredObject) return; 
            addSelectedPoint(hoveredObject.userData.pos);
        }
    }

    function updateMouse(event) {
        const rect = renderer.domElement.getBoundingClientRect();
        mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
        mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
    }

    function addSelectedPoint(pos) {
        selectedPoints.push(pos.clone());
        const markerGeo = new THREE.SphereGeometry(0.18, 16, 16); 
        const markerMat = new THREE.MeshBasicMaterial({ color: 0xff0000 });
        const marker = new THREE.Mesh(markerGeo, markerMat);
        marker.position.copy(pos);
        contentGroup.add(marker); 
        pointMarkers.push(marker);
        updatePointCountUI();
        if (selectedPoints.length >= 3) alignCutterToPoints();
    }

    function clearPoints() {
        selectedPoints = [];
        pointMarkers.forEach(m => contentGroup.remove(m));
        pointMarkers = [];
        updatePointCountUI();
    }
    
    function updatePointCountUI() {
        const el = document.getElementById('points-count-display');
        el.innerText = `選択数: ${selectedPoints.length}点`;
        el.style.color = selectedPoints.length >= 3 ? '#28a745' : '#007bff';
    }

    function alignCutterToPoints() {
        if (selectedPoints.length < 3) return;
        const p1 = selectedPoints[0];
        const p2 = selectedPoints[1];
        const p3 = selectedPoints[2];
        const plane = new THREE.Plane();
        plane.setFromCoplanarPoints(p1, p2, p3);
        const coplanarPoint = plane.normal.clone().multiplyScalar(-plane.constant);
        cutterGroup.position.copy(coplanarPoint);
        const defaultNormal = new THREE.Vector3(0, 1, 0);
        const targetNormal = plane.normal.clone();
        const quaternion = new THREE.Quaternion();
        quaternion.setFromUnitVectors(defaultNormal, targetNormal);
        cutterGroup.setRotationFromQuaternion(quaternion);
        cutterGroup.updateMatrixWorld();
    }

    function updateCutterTransform() {
        if (currentMode !== 'slider') return; 
        const y = parseFloat(document.getElementById('cut-y').value);
        const rx = parseFloat(document.getElementById('cut-rx').value);
        const rz = parseFloat(document.getElementById('cut-rz').value);
        cutterGroup.position.set(0, y, 0);
        cutterGroup.rotation.set(
            THREE.MathUtils.degToRad(rx),
            0,
            THREE.MathUtils.degToRad(rz)
        );
        document.getElementById('val-y').innerText = y.toFixed(2);
        document.getElementById('val-rx').innerText = rx + "°";
        document.getElementById('val-rz').innerText = rz + "°";
    }

    function performCut(inverse) {
        if (!currentShapeBrush) return;
        const historyGeometry = currentShapeBrush.geometry.clone();
        historyStack.push({ geo: historyGeometry });
        try {
            invisibleCutterBrush.updateMatrixWorld();
            invisibleCutterBrush.scale.y = inverse ? -1 : 1;
            invisibleCutterBrush.updateMatrixWorld();
            const resultBrush = evaluator.evaluate(currentShapeBrush, invisibleCutterBrush, SUBTRACTION);
            
            contentGroup.remove(currentShapeBrush);
            currentShapeBrush = resultBrush;
            updateMaterial();
            currentShapeBrush.castShadow = true;
            currentShapeBrush.receiveShadow = true;
            contentGroup.add(currentShapeBrush);
            invisibleCutterBrush.scale.y = 1;
            clearPoints();
            helperGroup.visible = false;
            createLabels(currentShapeBrush.geometry, currentShapeBrush);
        } catch (err) {
            console.error("Cut failed:", err);
        }
        updateUI();
    }

    function undo() {
        if (historyStack.length === 0) return;
        const state = historyStack.pop();
        contentGroup.remove(currentShapeBrush);
        currentShapeBrush = new Brush(state.geo, materialStandard);
        updateMaterial();
        currentShapeBrush.castShadow = true;
        currentShapeBrush.receiveShadow = true;
        contentGroup.add(currentShapeBrush);
        
        if (historyStack.length === 0) { 
             createShape(document.getElementById('shape-select').value);
        } else {
             helperGroup.visible = false;
             createLabels(currentShapeBrush.geometry, currentShapeBrush);
        }
        updateUI();
    }

    function updateMaterial() {
        const isWire = document.getElementById('wireframe-check').checked;
        if (isWire) {
            currentShapeBrush.material = new THREE.MeshBasicMaterial({ wireframe: true, color: 0x333333 });
        } else {
            currentShapeBrush.material = materialStandard;
        }
    }

    document.getElementById('grid-visible-check').addEventListener('change', (e) => {
        gridHelper.visible = e.target.checked;
        axesHelper.visible = e.target.checked;
    });
    document.getElementById('slider-visible-check').addEventListener('change', (e) => {
        const wrapper = document.getElementById('slider-controls-wrapper');
        wrapper.style.display = e.target.checked ? 'block' : 'none';
    });
    document.getElementById('plane-visible-check').addEventListener('change', (e) => {
        visualPlane.visible = e.target.checked;
    });
    document.getElementById('labels-visible-check').addEventListener('change', (e) => {
        if(e.target.checked) {
            createLabels(currentShapeBrush.geometry, currentShapeBrush);
        } else {
            vertexLabels.forEach(l => l.element.style.display = 'none');
        }
    });

    // モード切替処理
    window.switchMode = function(mode) {
        currentMode = mode;
        document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
        document.querySelectorAll('.mode-content').forEach(c => c.classList.remove('active'));
        
        // ARボタンの表示制御
        if(mode === 'ar') {
            arButton.style.display = 'block'; // ARタブのときだけボタンを出す
            document.querySelector('.tab-btn:nth-child(3)').classList.add('active');
            document.getElementById('mode-ar').classList.add('active');
            helperGroup.visible = false;
        } else {
            arButton.style.display = 'none'; // それ以外は隠す
            
            if(mode === 'slider') {
                document.querySelector('.tab-btn:nth-child(1)').classList.add('active');
                document.getElementById('mode-slider').classList.add('active');
                helperGroup.visible = false;
            } else if (mode === 'points') {
                document.querySelector('.tab-btn:nth-child(2)').classList.add('active');
                document.getElementById('mode-points').classList.add('active');
                helperGroup.visible = true;
                if(historyStack.length === 0 && interactionObjects.length === 0) {
                    createSnapPoints(currentShapeBrush.geometry, currentShapeBrush);
                }
            }
        }
    };

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function render(timestamp, frame) {
        if (renderer.xr.isPresenting) {
            if (frame) {
                const referenceSpace = renderer.xr.getReferenceSpace();
                const session = renderer.xr.getSession();
                if (hitTestSourceRequested === false) {
                    session.requestReferenceSpace('viewer').then(function (referenceSpace) {
                        session.requestHitTestSource({ space: referenceSpace }).then(function (source) {
                            hitTestSource = source;
                        });
                    });
                    session.addEventListener('end', function () {
                        hitTestSourceRequested = false;
                        hitTestSource = null;
                    });
                    hitTestSourceRequested = true;
                }
                if (hitTestSource) {
                    const hitTestResults = frame.getHitTestResults(hitTestSource);
                    if (hitTestResults.length > 0) {
                        const hit = hitTestResults[0];
                        reticle.visible = true;
                        reticle.matrix.fromArray(hit.getPose(referenceSpace).transform.matrix);
                    } else {
                        reticle.visible = false;
                    }
                }
            }
        } else {
            controls.update();
            reticle.visible = false;
        }
        updateLabels();
        renderer.render(scene, camera);
    }

    document.getElementById('shape-select').addEventListener('change', (e) => createShape(e.target.value));
    ['cut-y', 'cut-rx', 'cut-rz'].forEach(id => document.getElementById(id).addEventListener('input', updateCutterTransform));
    document.getElementById('reset-slider-btn').addEventListener('click', () => {
        document.getElementById('cut-rx').value = 0; document.getElementById('cut-rz').value = 0; updateCutterTransform();
    });
    document.getElementById('clear-points-btn').addEventListener('click', clearPoints);
    document.getElementById('cut-btn').addEventListener('click', () => performCut(false));
    document.getElementById('cut-btn-inverse').addEventListener('click', () => performCut(true));
    document.getElementById('undo-btn').addEventListener('click', undo);
    document.getElementById('reset-btn').addEventListener('click', () => createShape(document.getElementById('shape-select').value));
    document.getElementById('wireframe-check').addEventListener('change', updateMaterial);
</script>
</body>
</html>
