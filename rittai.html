<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>ç«‹ä½“åˆ‡æ–­ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ãƒ¼ v17</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: "Helvetica Neue", Arial, sans-serif; background-color: #f0f0f0; }
        #canvas-container { width: 100vw; height: 100vh; position: relative; touch-action: none; }
        
        #loading-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #fff; z-index: 9999; display: flex; flex-direction: column;
            justify-content: center; align-items: center; color: #333;
        }
        #error-message { color: red; margin-top: 10px; padding: 20px; text-align: center; display: none; }

        .vertex-label {
            position: absolute;
            background: rgba(255, 255, 255, 0.85);<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>ç«‹ä½“åˆ‡æ–­ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ãƒ¼ v18</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: "Helvetica Neue", Arial, sans-serif; background-color: #f0f0f0; }
        /* touch-action: none ã§ã‚¹ãƒãƒ›ã§ã®ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«å¹²æ¸‰ã‚’é˜²æ­¢ */
        #canvas-container { width: 100vw; height: 100vh; position: relative; touch-action: none; }
        
        #loading-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #fff; z-index: 9999; display: flex; flex-direction: column;
            justify-content: center; align-items: center; color: #333;
        }
        #error-message { color: red; margin-top: 10px; padding: 20px; text-align: center; display: none; }

        .vertex-label {
            position: absolute;
            background: rgba(255, 255, 255, 0.85);
            border: 1px solid #333;
            border-radius: 50%;
            width: 20px; height: 20px;
            text-align: center; line-height: 20px;
            font-size: 12px; font-weight: bold; color: #000;
            pointer-events: none;
            z-index: 5;
            transform: translate(-50%, -50%);
            display: none; 
        }

        /* UIãƒ‘ãƒãƒ« */
        #ui-panel {
            background: rgba(255, 255, 255, 0.95);
            padding: 15px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.15);
            z-index: 10;
            font-size: 14px;
            display: none;
            transition: transform 0.3s ease;
        }

        /* PCç”¨ */
        @media (min-width: 601px) {
            #ui-panel {
                position: absolute; top: 10px; left: 10px;
                width: 340px; border-radius: 8px;
                max-height: 90vh; overflow-y: auto;
            }
            #mobile-toggle-btn { display: none; }
            #panel-header-mobile { display: none; }
        }

        /* ã‚¹ãƒãƒ›ç”¨ */
        @media (max-width: 600px) {
            #ui-panel {
                position: absolute; bottom: 0; left: 0;
                width: 100%; 
                border-radius: 20px 20px 0 0;
                max-height: 60vh;
                overflow-y: auto;
                box-sizing: border-box;
                padding-bottom: 40px;
                transform: translateY(0);
            }
            #ui-panel.closed {
                transform: translateY(110%);
            }
            #mobile-toggle-btn {
                position: absolute; bottom: 20px; right: 20px;
                width: 50px; height: 50px;
                background: #007bff; color: white;
                border-radius: 50%;
                border: none;
                box-shadow: 0 4px 10px rgba(0,0,0,0.3);
                font-size: 24px;
                display: flex; justify-content: center; align-items: center;
                z-index: 20;
                cursor: pointer;
            }
            #panel-header-mobile {
                display: flex; justify-content: space-between; align-items: center;
                margin-bottom: 15px; border-bottom: 1px solid #eee; padding-bottom: 10px;
            }
        }

        h2 { margin-top: 0; font-size: 16px; color: #333; margin-bottom: 0; }
        
        .tab-container { display: flex; margin-bottom: 15px; border-bottom: 1px solid #ddd; }
        .tab-btn {
            flex: 1; padding: 8px 4px; text-align: center; cursor: pointer;
            background: #f8f9fa; border: 1px solid #ddd; border-bottom: none;
            margin-right: 2px; border-radius: 4px 4px 0 0; color: #666; font-size: 12px; white-space: nowrap;
        }
        .tab-btn.active { background: #fff; font-weight: bold; color: #007bff; border-bottom: 2px solid #fff; margin-bottom: -1px; }
        
        .mode-content { display: none; }
        .mode-content.active { display: block; }
        .control-group { margin-bottom: 15px; padding-bottom: 10px; border-bottom: 1px solid #eee; }
        .control-group:last-child { border-bottom: none; }
        
        label { display: block; margin-bottom: 5px; font-weight: bold; color: #444; cursor: pointer; }
        .checkbox-label { font-weight: normal; display: flex; align-items: center; gap: 5px; margin-bottom: 5px; }

        button {
            width: 100%; padding: 12px; margin-bottom: 8px;
            background-color: #007bff; color: white; border: none;
            border-radius: 8px; cursor: pointer; transition: background 0.2s; font-size: 14px;
        }
        button:hover { background-color: #0056b3; }
        button.secondary { background-color: #6c757d; }
        button.danger { background-color: #dc3545; }
        button:disabled { background-color: #ccc; cursor: not-allowed; opacity: 0.7; }
        
        #ios-ar-btn { background-color: #28a745; display: none; margin-top: 10px; }
        
        select { width: 100%; padding: 8px; border-radius: 4px; border: 1px solid #ccc; font-size: 16px; }
        input[type=range] { width: 100%; cursor: pointer; height: 30px; }
        .value-display { float: right; font-weight: normal; font-family: monospace; }
        .hint-text { font-size: 12px; color: #666; margin-top: -2px; margin-bottom: 8px; line-height: 1.4; }
        .debug-info { font-size: 12px; background: #e2e3e5; padding: 10px; border-radius: 5px; color: #383d41; margin-bottom: 10px; }
    </style>
    <script>
        window.addEventListener('error', function(e) {
            const overlay = document.getElementById('loading-overlay');
            const msg = document.getElementById('error-message');
            if(overlay && msg) {
                if (e.message && (e.message.includes('xr') || e.message.includes('XR'))) return;
                overlay.style.display = 'flex';
                msg.style.display = 'block';
                msg.innerHTML = '<strong>ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ:</strong><br>' + e.message + '<br><br>ãƒšãƒ¼ã‚¸ã‚’å†èª­ã¿è¾¼ã¿ã—ã¦ãã ã•ã„ã€‚';
            }
        });
    </script>
</head>
<body>

<div id="loading-overlay">
    <div id="status-text">ã‚·ã‚¹ãƒ†ãƒ èª­ã¿è¾¼ã¿ä¸­...</div>
    <div id="error-message"></div>
</div>

<div id="canvas-container">
    <div id="labels-container"></div>
</div>

<button id="mobile-toggle-btn" onclick="togglePanel()">âš™ï¸</button>

<div id="ui-panel">
    <div id="panel-header-mobile">
        <h2>è¨­å®šãƒ»æ“ä½œ</h2>
        <button onclick="togglePanel()" style="width:auto; padding:6px 12px; margin:0; background:#ddd; color:#333;">â–¼ é–‰ã˜ã‚‹</button>
    </div>

    <div class="control-group">
        <label>å›³å½¢é¸æŠ</label>
        <select id="shape-select">
            <option value="cube">ç«‹æ–¹ä½“</option>
            <option value="prism">æ­£å››è§’æŸ±</option>
            <option value="pyramid">æ­£å››è§’éŒ</option>
            <option value="tri_pyramid">æ­£ä¸‰è§’éŒ</option>
            <option value="cylinder">å††æŸ±</option>
        </select>
        <button id="reset-btn" class="secondary" style="margin-top:5px; padding:8px;">å›³å½¢ã‚’ãƒªã‚»ãƒƒãƒˆ</button>
    </div>

    <div class="tab-container">
        <div class="tab-btn active" onclick="switchMode('slider')">â‘  ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼</div>
        <div class="tab-btn" onclick="switchMode('points')">â‘¡ ç‚¹æŒ‡å®š</div>
        <div class="tab-btn" onclick="switchMode('ar')">â‘¢ ARã§ç¢ºèª</div>
    </div>

    <div id="mode-slider" class="mode-content active">
        <div class="control-group">
            <label>åˆ‡æ–­é¢ã®èª¿æ•´</label>
            <label>é«˜ã• (Y) <span id="val-y" class="value-display">0.00</span></label>
            <input type="range" id="cut-y" min="-3" max="3" step="0.01" value="0">
            <label>å›è»¢ (X:æ‰‹å‰å¥¥) <span id="val-rx" class="value-display">0Â°</span></label>
            <input type="range" id="cut-rx" min="-180" max="180" step="1" value="0">
            <label>å›è»¢ (Z:å·¦å³) <span id="val-rz" class="value-display">0Â°</span></label>
            <input type="range" id="cut-rz" min="-180" max="180" step="1" value="0">
            <button class="secondary" id="reset-slider-btn" style="font-size:12px; padding:8px; margin-top:5px;">è§’åº¦ã‚’æ°´å¹³ã«æˆ»ã™</button>
        </div>
    </div>

    <div id="mode-points" class="mode-content">
        <div class="control-group">
            <label>åˆ‡æ–­ç‚¹ã®é¸æŠ</label>
            <p class="hint-text">â— <b>é ‚ç‚¹</b> (å¤§) / â— <b>ä¸­ç‚¹ãƒ»3ç­‰åˆ†ç‚¹</b> (å°)</p>
            <div style="display:flex; gap:5px;">
                <button id="clear-points-btn" class="danger" style="font-size:12px;">é¸æŠã‚¯ãƒªã‚¢</button>
            </div>
            <p id="points-count-display" style="font-weight:bold; color:#007bff; margin:5px 0;">é¸æŠæ•°: 0ç‚¹</p>
        </div>
    </div>

    <div id="mode-ar" class="mode-content">
        <div class="control-group">
            <label>ARï¼ˆæ‹¡å¼µç¾å®Ÿï¼‰ãƒ¢ãƒ¼ãƒ‰</label>
            <div id="ar-debug-info" class="debug-info">è¨ºæ–­ä¸­...</div>
            <div id="webxr-instructions" style="display:none;">
                <p class="hint-text">1. ä¸‹ã® <b>[START AR]</b> ã‚’æŠ¼ã™<br>2. ç™½ã„ãƒªãƒ³ã‚°ãŒå‡ºãŸã‚‰ã‚¿ãƒƒãƒ—</p>
            </div>
            <button id="ios-ar-btn">ğŸ“± AR Quick Look (iOS)</button>
            <p id="ios-hint" class="hint-text" style="display:none;">
                ãƒœã‚¿ãƒ³ã‚’æŠ¼ã™ã¨ARãƒ“ãƒ¥ãƒ¼ã‚¢ãƒ¼ãŒèµ·å‹•ã—ã¾ã™ã€‚
            </p>
        </div>
    </div>

    <div class="control-group">
        <label>åˆ‡æ–­å®Ÿè¡Œ</label>
        <button id="cut-btn">âœ‚ï¸ åˆ‡æ–­ (åŸºæœ¬)</button>
        <button id="cut-btn-inverse">âœ‚ï¸ åˆ‡æ–­ (é€†å´ã‚’æ®‹ã™)</button>
    </div>

    <div class="control-group">
        <button id="undo-btn" class="secondary" disabled>â†©ï¸ ã²ã¨ã¤æˆ»ã‚‹ (Undo)</button>
        <div style="margin-top:15px; padding-top:10px; border-top:1px solid #ddd;">
             <label class="checkbox-label"><input type="checkbox" id="wireframe-check"> ãƒ¯ã‚¤ãƒ¤ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ </label>
             <label class="checkbox-label"><input type="checkbox" id="grid-visible-check" checked> ã‚°ãƒªãƒƒãƒ‰è¡¨ç¤º</label>
             <label class="checkbox-label"><input type="checkbox" id="labels-visible-check" checked> ç‚¹ãƒ©ãƒ™ãƒ«(A,B..)</label>
             <label class="checkbox-label"><input type="checkbox" id="plane-visible-check" checked> åˆ‡æ–­é¢è¡¨ç¤º</label>
        </div>
    </div>
</div>

<script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
            "three-mesh-bvh": "https://unpkg.com/three-mesh-bvh@0.7.0/build/index.module.js",
            "three-bvh-csg": "https://unpkg.com/three-bvh-csg@0.0.16/build/index.module.js"
        }
    }
</script>

<script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { ARButton } from 'three/addons/webxr/ARButton.js';
    import { USDZExporter } from 'three/addons/exporters/USDZExporter.js';
    import { SUBTRACTION, Brush, Evaluator } from 'three-bvh-csg';

    const overlay = document.getElementById('loading-overlay');
    if(overlay) overlay.style.display = 'none';
    document.getElementById('ui-panel').style.display = 'block';

    // ã‚¹ãƒãƒ›ç”¨åˆæœŸåŒ–
    if (window.innerWidth <= 600) {
        document.getElementById('ui-panel').classList.add('closed');
    } else {
        document.getElementById('mobile-toggle-btn').style.display = 'none';
    }
    window.togglePanel = function() {
        const panel = document.getElementById('ui-panel');
        const btn = document.getElementById('mobile-toggle-btn');
        if (panel.classList.contains('closed')) {
            panel.classList.remove('closed');
            btn.style.display = 'none';
        } else {
            panel.classList.add('closed');
            btn.style.display = 'flex';
        }
    };

    // --- ç’°å¢ƒåˆ¤å®š ---
    let isWebXRAvailable = ('xr' in navigator);
    const isIos = /iPhone|iPad|iPod/i.test(navigator.userAgent);
    
    function checkAREnvironment() {
        const debugEl = document.getElementById('ar-debug-info');
        const webxrInst = document.getElementById('webxr-instructions');
        const iosBtn = document.getElementById('ios-ar-btn');
        const iosHint = document.getElementById('ios-hint');
        let html = "";
        if (isWebXRAvailable && !isIos) {
            html += "ç«¯æœ«: Android (WebXRå¯¾å¿œ)";
            webxrInst.style.display = 'block';
            return 'webxr';
        } else if (isIos) {
            html += "ç«¯æœ«: iOS (AR Quick Look)";
            iosBtn.style.display = 'block';
            iosHint.style.display = 'block';
            return 'ios';
        } else {
            html += "ç«¯æœ«: PC (ARéå¯¾å¿œ)";
            return 'none';
        }
        debugEl.innerHTML = html;
    }
    const arMode = checkAREnvironment();

    // --- 3Dã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ— ---
    const container = document.getElementById('canvas-container');
    const labelsContainer = document.getElementById('labels-container');
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xfafafa);
    const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
    camera.position.set(6, 5, 8);
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    if (isWebXRAvailable) renderer.xr.enabled = true; 
    container.appendChild(renderer.domElement);

    // WebXR Button
    if (arMode === 'webxr') {
        try {
            const webXrButton = ARButton.createButton(renderer, { 
                requiredFeatures: ['hit-test'], optionalFeatures: ['dom-overlay'],
                domOverlay: { root: document.getElementById('ui-panel') } 
            });
            document.body.appendChild(webXrButton);
            webXrButton.style.display = 'none';
            window.webXrButton = webXrButton;
        } catch(e) {}
    }

    // iOS Export
    document.getElementById('ios-ar-btn').addEventListener('click', async () => {
        if (!currentShapeBrush) return;
        const btn = document.getElementById('ios-ar-btn');
        const originalText = btn.innerText;
        btn.innerText = "ç”Ÿæˆä¸­..."; btn.disabled = true;
        try {
            const exporter = new USDZExporter();
            const clone = currentShapeBrush.clone();
            clone.scale.set(0.05, 0.05, 0.05);
            clone.rotation.x = -Math.PI / 2;
            clone.updateMatrixWorld();
            const arraybuffer = await exporter.parse(clone);
            const blob = new Blob([arraybuffer], { type: 'model/vnd.usdz+zip' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.rel = 'ar'; link.href = url;
            link.appendChild(document.createElement('img'));
            link.click();
            btn.innerText = originalText; btn.disabled = false;
        } catch(err) {
            alert("ã‚¨ãƒ©ãƒ¼: " + err.message);
            btn.innerText = originalText; btn.disabled = false;
        }
    });

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    const ambientLight = new THREE.AmbientLight(0xffffff, 2.5); scene.add(ambientLight);
    const dirLight = new THREE.DirectionalLight(0xffffff, 0.5); dirLight.position.set(5, 10, 7); dirLight.castShadow = true; scene.add(dirLight);
    const fillLight = new THREE.DirectionalLight(0xffffff, 0.5); fillLight.position.set(-5, 0, -5); scene.add(fillLight);

    let contentGroup = new THREE.Group(); scene.add(contentGroup);
    let currentShapeBrush, materialStandard, cutterGroup, visualPlane, invisibleCutterBrush;
    let currentMode = 'slider'; 
    let interactionObjects = [], selectedPoints = [], pointMarkers = [];
    let raycaster = new THREE.Raycaster(), mouse = new THREE.Vector2(), hoveredObject = null;    
    let helperGroup = new THREE.Group(); contentGroup.add(helperGroup);
    let vertexLabels = [], gridHelper, axesHelper;
    const evaluator = new Evaluator();
    let reticle, hitTestSource = null, hitTestSourceRequested = false;
    let historyStack = [];

    materialStandard = new THREE.MeshStandardMaterial({ color: 0x66ccff, roughness: 0.5, metalness: 0.0, transparent: true, opacity: 0.9, side: THREE.DoubleSide });

    init();

    function init() {
        try {
            gridHelper = new THREE.GridHelper(20, 20, 0xcccccc, 0xe5e5e5); contentGroup.add(gridHelper);
            axesHelper = new THREE.AxesHelper(5); contentGroup.add(axesHelper);
            setupCutterSystem(); createShape('cube'); updateCutterTransform();
            reticle = new THREE.Mesh(new THREE.RingGeometry(0.15, 0.2, 32).rotateX(-Math.PI / 2), new THREE.MeshBasicMaterial({ color: 0xffffff }));
            reticle.matrixAutoUpdate = false; reticle.visible = false; scene.add(reticle); 
            window.addEventListener('resize', onWindowResize);
            renderer.domElement.addEventListener('pointermove', onPointerMove); 
            
            // é‡è¦ãªå¤‰æ›´: PointerDownã‚¤ãƒ™ãƒ³ãƒˆã®ç™»éŒ²
            renderer.domElement.addEventListener('pointerdown', onPointerDown); 
            
            if (isWebXRAvailable) {
                renderer.xr.addEventListener('sessionstart', onSessionStart);
                renderer.xr.addEventListener('sessionend', onSessionEnd);
            }
            renderer.setAnimationLoop(render); 
        } catch (e) { console.error(e); }
    }

    function onSessionStart() { contentGroup.scale.set(0.05, 0.05, 0.05); scene.background = null; }
    function onSessionEnd() { contentGroup.scale.set(1, 1, 1); contentGroup.position.set(0, 0, 0); contentGroup.rotation.set(0, 0, 0); scene.background = new THREE.Color(0xfafafa); reticle.visible = false; hitTestSource = null; hitTestSourceRequested = false; }

    function setupCutterSystem() {
        cutterGroup = new THREE.Group(); contentGroup.add(cutterGroup); 
        const planeGeo = new THREE.PlaneGeometry(12, 12);
        const planeMat = new THREE.MeshBasicMaterial({ color: 0x007bff, opacity: 0.2, transparent: true, side: THREE.DoubleSide, depthWrite: false });
        visualPlane = new THREE.Mesh(planeGeo, planeMat); visualPlane.rotation.x = -Math.PI / 2;
        const edges = new THREE.EdgesGeometry(planeGeo);
        const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0x0000ff, opacity: 0.3, transparent:true }));
        visualPlane.add(line); cutterGroup.add(visualPlane);
        const boxSize = 30;
        const boxGeo = new THREE.BoxGeometry(boxSize, boxSize, boxSize); boxGeo.translate(0, boxSize / 2, 0); 
        invisibleCutterBrush = new Brush(boxGeo, new THREE.MeshBasicMaterial({ visible: false })); cutterGroup.add(invisibleCutterBrush);
    }

    function createShape(type) {
        let geometry;
        switch(type) {
            case 'cube': geometry = new THREE.BoxGeometry(3, 3, 3); break;
            case 'prism': geometry = new THREE.BoxGeometry(2, 4, 2); break;
            case 'pyramid': geometry = new THREE.ConeGeometry(2, 3.5, 4); break;
            case 'tri_pyramid': geometry = new THREE.ConeGeometry(2, 3.5, 3); break;
            case 'cylinder': geometry = new THREE.CylinderGeometry(1.5, 1.5, 4, 32); break;
        }
        if (currentShapeBrush) contentGroup.remove(currentShapeBrush);
        currentShapeBrush = new Brush(geometry, materialStandard);
        currentShapeBrush.castShadow = true; currentShapeBrush.receiveShadow = true;
        contentGroup.add(currentShapeBrush);
        historyStack = [];
        createSnapPoints(geometry, currentShapeBrush); createLabels(geometry, currentShapeBrush); 
        updateUI(); 
    }

    function updateUI() { const undoBtn = document.getElementById('undo-btn'); if (undoBtn) undoBtn.disabled = (historyStack.length === 0); }

    function createLabels(geometry, mesh) {
        vertexLabels.forEach(l => l.element.remove()); vertexLabels = [];
        if (!document.getElementById('labels-visible-check').checked) return;
        const posAttr = geometry.attributes.position; const uniquePoints = []; const threshold = 0.01;
        for (let i = 0; i < posAttr.count; i++) {
            const v = new THREE.Vector3().fromBufferAttribute(posAttr, i);
            let exists = false; for (let p of uniquePoints) { if (p.distanceTo(v) < threshold) { exists = true; break; } }
            if (!exists) uniquePoints.push(v);
        }
        uniquePoints.sort((a, b) => { if (Math.abs(b.y - a.y) > 0.1) return b.y - a.y; if (Math.abs(b.x - a.x) > 0.1) return a.x - b.x; return a.z - b.z; });
        const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
        uniquePoints.forEach((localPos, index) => {
            if (index >= chars.length) return;
            const labelText = chars[index]; const div = document.createElement('div'); div.className = 'vertex-label'; div.innerText = labelText; labelsContainer.appendChild(div);
            vertexLabels.push({ element: div, localPos: localPos.clone(), mesh: mesh });
        });
    }
    function updateLabels() {
        if (vertexLabels.length === 0) return;
        const isVisible = document.getElementById('labels-visible-check').checked;
        if (!isVisible) { vertexLabels.forEach(l => l.element.style.display = 'none'); return; }
        const widthHalf = window.innerWidth / 2; const heightHalf = window.innerHeight / 2;
        vertexLabels.forEach(label => {
            const worldPos = label.localPos.clone().applyMatrix4(label.mesh.matrixWorld); const pos = worldPos.clone(); pos.project(camera);
            if (pos.z > 1) { label.element.style.display = 'none'; } else {
                label.element.style.display = 'block';
                const x = (pos.x * widthHalf) + widthHalf; const y = -(pos.y * heightHalf) + heightHalf;
                label.element.style.left = `${x}px`; label.element.style.top = `${y}px`;
            }
        });
    }
    function createSnapPoints(geometry, mesh) {
        helperGroup.clear(); interactionObjects = [];
        const addedPoints = new Set(); 
        function addSnapSphere(pos, type) {
            const key = `${pos.x.toFixed(3)},${pos.y.toFixed(3)},${pos.z.toFixed(3)}`;
            if (addedPoints.has(key)) return; addedPoints.add(key);
            const size = (type === 'vertex') ? 0.15 : 0.08; const color = (type === 'vertex') ? 0x333333 : 0x666666; const opacity = (type === 'vertex') ? 0.6 : 0.4;
            const geo = new THREE.SphereGeometry(size, 16, 16); const mat = new THREE.MeshBasicMaterial({ color: color, transparent: true, opacity: opacity });
            const sphere = new THREE.Mesh(geo, mat); sphere.position.copy(pos);
            sphere.userData = { isSnapPoint: true, originalColor: color, hoverColor: 0xffaa00, pos: pos.clone() };
            helperGroup.add(sphere); interactionObjects.push(sphere);
        }
        const posAttr = geometry.attributes.position; for(let i=0; i<posAttr.count; i++){ addSnapSphere(new THREE.Vector3().fromBufferAttribute(posAttr, i), 'vertex'); }
        const edgesGeo = new THREE.EdgesGeometry(geometry, 20); const edgePos = edgesGeo.attributes.position;
        for (let i = 0; i < edgePos.count; i += 2) {
            const start = new THREE.Vector3().fromBufferAttribute(edgePos, i); const end = new THREE.Vector3().fromBufferAttribute(edgePos, i + 1);
            addSnapSphere(start.clone().lerp(end, 0.5), 'sub'); addSnapSphere(start.clone().lerp(end, 1/3), 'sub'); addSnapSphere(start.clone().lerp(end, 2/3), 'sub');
        }
    }

    function onPointerMove(event) {
        if (currentMode !== 'points') return; if (renderer.xr.isPresenting) return; 
        // ã‚¹ãƒãƒ›ã®ã‚¿ãƒƒãƒæ“ä½œã§ã¯hoveredObjectã‚’æ›´æ–°ã—ãªã„ï¼ˆã‚«ãƒ¼ã‚½ãƒ«ãŒãªã„ãŸã‚ï¼‰
        // PCã®ãƒã‚¦ã‚¹æ“ä½œã®ã¨ãã®ã¿è¦–è¦šçš„ãªãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯ã‚’è¡Œã†
        if (event.pointerType === 'mouse') {
             updateMouse(event); raycaster.setFromCamera(mouse, camera);
             const intersects = raycaster.intersectObjects(interactionObjects);
             if (intersects.length > 0) {
                 const obj = intersects[0].object;
                 if (hoveredObject !== obj) {
                     if (hoveredObject) hoveredObject.material.color.setHex(hoveredObject.userData.originalColor);
                     hoveredObject = obj; hoveredObject.material.color.setHex(obj.userData.hoverColor); document.body.style.cursor = 'pointer';
                 }
             } else {
                 if (hoveredObject) { hoveredObject.material.color.setHex(hoveredObject.userData.originalColor); hoveredObject = null; document.body.style.cursor = 'default'; }
             }
        }
    }

    // --- ä¿®æ­£ã•ã‚ŒãŸPointerDownãƒãƒ³ãƒ‰ãƒ© (ã‚¿ãƒƒãƒå¯¾å¿œ) ---
    function onPointerDown(event) {
        if (renderer.xr.isPresenting) return; 
        if (currentMode !== 'points') return;

        // 1. åº§æ¨™ã®å–å¾— (PointerEventã¯æ±ç”¨çš„ã ãŒå¿µã®ãŸã‚æ­£è¦åŒ–)
        const rect = renderer.domElement.getBoundingClientRect();
        mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
        mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

        // 2. ã‚¯ãƒªãƒƒã‚¯/ã‚¿ãƒƒãƒ—ã—ãŸç¬é–“ã«Raycasterã‚’é£›ã°ã™ (HoverçŠ¶æ…‹ã«ä¾å­˜ã—ãªã„)
        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects(interactionObjects);

        // 3. å½“ãŸã‚Šåˆ¤å®šãŒã‚ã‚Œã°é¸æŠ
        if (intersects.length > 0) {
            // ä¸€ç•ªæ‰‹å‰ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’æ¡ç”¨
            const hitObj = intersects[0].object;
            addSelectedPoint(hitObj.userData.pos);
            
            // è¦–è¦šãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯ï¼ˆä¸€ç¬å…‰ã‚‰ã›ã‚‹ãªã©ï¼‰
            hitObj.material.color.setHex(0x00ff00);
            setTimeout(() => {
                if(hitObj) hitObj.material.color.setHex(hitObj.userData.originalColor);
            }, 200);
        }
    }

    if (isWebXRAvailable) {
        const controller = renderer.xr.getController(0);
        controller.addEventListener('select', function() {
            if (reticle.visible) { reticle.matrix.decompose(contentGroup.position, contentGroup.quaternion, contentGroup.scale); contentGroup.scale.set(0.05, 0.05, 0.05); }
        }); scene.add(controller);
    }

    function updateMouse(event) {
        const rect = renderer.domElement.getBoundingClientRect();
        mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1; mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
    }
    function addSelectedPoint(pos) {
        selectedPoints.push(pos.clone());
        const markerGeo = new THREE.SphereGeometry(0.18, 16, 16); const markerMat = new THREE.MeshBasicMaterial({ color: 0xff0000 });
        const marker = new THREE.Mesh(markerGeo, markerMat); marker.position.copy(pos); contentGroup.add(marker); pointMarkers.push(marker);
        updatePointCountUI(); if (selectedPoints.length >= 3) alignCutterToPoints();
    }
    function clearPoints() { selectedPoints = []; pointMarkers.forEach(m => contentGroup.remove(m)); pointMarkers = []; updatePointCountUI(); }
    function updatePointCountUI() { const el = document.getElementById('points-count-display'); el.innerText = `é¸æŠæ•°: ${selectedPoints.length}ç‚¹`; el.style.color = selectedPoints.length >= 3 ? '#28a745' : '#007bff'; }
    function alignCutterToPoints() {
        if (selectedPoints.length < 3) return;
        const p1 = selectedPoints[0]; const p2 = selectedPoints[1]; const p3 = selectedPoints[2];
        const plane = new THREE.Plane(); plane.setFromCoplanarPoints(p1, p2, p3);
        const coplanarPoint = plane.normal.clone().multiplyScalar(-plane.constant);
        cutterGroup.position.copy(coplanarPoint);
        const defaultNormal = new THREE.Vector3(0, 1, 0); const targetNormal = plane.normal.clone();
        const quaternion = new THREE.Quaternion(); quaternion.setFromUnitVectors(defaultNormal, targetNormal);
        cutterGroup.setRotationFromQuaternion(quaternion); cutterGroup.updateMatrixWorld();
    }
    function updateCutterTransform() {
        if (currentMode !== 'slider') return; 
        const y = parseFloat(document.getElementById('cut-y').value); const rx = parseFloat(document.getElementById('cut-rx').value); const rz = parseFloat(document.getElementById('cut-rz').value);
        cutterGroup.position.set(0, y, 0); cutterGroup.rotation.set(THREE.MathUtils.degToRad(rx), 0, THREE.MathUtils.degToRad(rz));
        document.getElementById('val-y').innerText = y.toFixed(2); document.getElementById('val-rx').innerText = rx + "Â°"; document.getElementById('val-rz').innerText = rz + "Â°";
    }
    function performCut(inverse) {
        if (!currentShapeBrush) return;
        const historyGeometry = currentShapeBrush.geometry.clone(); historyStack.push({ geo: historyGeometry });
        try {
            invisibleCutterBrush.updateMatrixWorld(); invisibleCutterBrush.scale.y = inverse ? -1 : 1; invisibleCutterBrush.updateMatrixWorld();
            const resultBrush = evaluator.evaluate(currentShapeBrush, invisibleCutterBrush, SUBTRACTION);
            contentGroup.remove(currentShapeBrush); currentShapeBrush = resultBrush;
            updateMaterial(); currentShapeBrush.castShadow = true; currentShapeBrush.receiveShadow = true;
            contentGroup.add(currentShapeBrush); invisibleCutterBrush.scale.y = 1; clearPoints(); helperGroup.visible = false; createLabels(currentShapeBrush.geometry, currentShapeBrush);
        } catch (err) { console.error("Cut failed:", err); } updateUI();
    }
    function undo() {
        if (historyStack.length === 0) return;
        const state = historyStack.pop(); contentGroup.remove(currentShapeBrush); currentShapeBrush = new Brush(state.geo, materialStandard);
        updateMaterial(); currentShapeBrush.castShadow = true; currentShapeBrush.receiveShadow = true; contentGroup.add(currentShapeBrush);
        if (historyStack.length === 0) { createShape(document.getElementById('shape-select').value); } else { helperGroup.visible = false; createLabels(currentShapeBrush.geometry, currentShapeBrush); } updateUI();
    }
    function updateMaterial() {
        const isWire = document.getElementById('wireframe-check').checked;
        if (isWire) { currentShapeBrush.material = new THREE.MeshBasicMaterial({ wireframe: true, color: 0x333333 }); } else { currentShapeBrush.material = materialStandard; }
    }

    document.getElementById('shape-select').addEventListener('change', (e) => createShape(e.target.value));
    ['cut-y', 'cut-rx', 'cut-rz'].forEach(id => document.getElementById(id).addEventListener('input', updateCutterTransform));
    document.getElementById('reset-slider-btn').addEventListener('click', () => { document.getElementById('cut-rx').value = 0; document.getElementById('cut-rz').value = 0; updateCutterTransform(); });
    document.getElementById('clear-points-btn').addEventListener('click', clearPoints);
    document.getElementById('cut-btn').addEventListener('click', () => performCut(false));
    document.getElementById('cut-btn-inverse').addEventListener('click', () => performCut(true));
    document.getElementById('undo-btn').addEventListener('click', undo);
    document.getElementById('reset-btn').addEventListener('click', () => createShape(document.getElementById('shape-select').value));
    document.getElementById('wireframe-check').addEventListener('change', updateMaterial);
    document.getElementById('grid-visible-check').addEventListener('change', (e) => { gridHelper.visible = e.target.checked; axesHelper.visible = e.target.checked; });
    document.getElementById('plane-visible-check').addEventListener('change', (e) => { visualPlane.visible = e.target.checked; });
    document.getElementById('labels-visible-check').addEventListener('change', (e) => { if(e.target.checked) { createLabels(currentShapeBrush.geometry, currentShapeBrush); } else { vertexLabels.forEach(l => l.element.style.display = 'none'); } });

    window.switchMode = function(mode) {
        currentMode = mode;
        document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
        document.querySelectorAll('.mode-content').forEach(c => c.classList.remove('active'));
        
        if(mode === 'ar') {
            if(window.webXrButton) window.webXrButton.style.display = 'block';
            document.querySelector('.tab-btn:nth-child(3)').classList.add('active');
            document.getElementById('mode-ar').classList.add('active');
            helperGroup.visible = false;
        } else {
            if(window.webXrButton) window.webXrButton.style.display = 'none'; 
            if(mode === 'slider') {
                document.querySelector('.tab-btn:nth-child(1)').classList.add('active');
                document.getElementById('mode-slider').classList.add('active');
                helperGroup.visible = false;
            } else if (mode === 'points') {
                document.querySelector('.tab-btn:nth-child(2)').classList.add('active');
                document.getElementById('mode-points').classList.add('active');
                helperGroup.visible = true;
                if(historyStack.length === 0 && interactionObjects.length === 0) { createSnapPoints(currentShapeBrush.geometry, currentShapeBrush); }
            }
        }
    };

    function onWindowResize() { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); }
    function render(timestamp, frame) {
        if (renderer.xr.isPresenting) {
            if (frame && hitTestSourceRequested === false) {
                const session = renderer.xr.getSession();
                session.requestReferenceSpace('viewer').then(function (referenceSpace) {
                    session.requestHitTestSource({ space: referenceSpace }).then(function (source) { hitTestSource = source; });
                });
                session.addEventListener('end', function () { hitTestSourceRequested = false; hitTestSource = null; });
                hitTestSourceRequested = true;
            }
            if (hitTestSource && frame) {
                const hitTestResults = frame.getHitTestResults(hitTestSource);
                if (hitTestResults.length > 0) {
                    const hit = hitTestResults[0]; const referenceSpace = renderer.xr.getReferenceSpace();
                    reticle.visible = true; reticle.matrix.fromArray(hit.getPose(referenceSpace).transform.matrix);
                } else { reticle.visible = false; }
            }
        } else { controls.update(); reticle.visible = false; }
        updateLabels(); renderer.render(scene, camera);
    }
</script>
</body>
</html>
