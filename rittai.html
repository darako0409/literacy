<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>ç«‹ä½“åˆ‡æ–­ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ãƒ¼ v15 (iOSå¯¾å¿œ)</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: "Helvetica Neue", Arial, sans-serif; background-color: #f0f0f0; }
        #canvas-container { width: 100vw; height: 100vh; position: relative; }
        
        #loading-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #fff; z-index: 9999; display: flex; flex-direction: column;
            justify-content: center; align-items: center; color: #333;
        }
        #error-message { color: red; margin-top: 10px; padding: 20px; text-align: center; display: none; }

        /* é ‚ç‚¹ãƒ©ãƒ™ãƒ« */
        .vertex-label {
            position: absolute;
            background: rgba(255, 255, 255, 0.85);
            border: 1px solid #333;
            border-radius: 50%;
            width: 20px; height: 20px;
            text-align: center; line-height: 20px;
            font-size: 12px; font-weight: bold; color: #000;
            pointer-events: none;
            z-index: 5;
            transform: translate(-50%, -50%);
            display: none; 
        }

        /* UIãƒ‘ãƒãƒ« */
        #ui-panel {
            position: absolute; top: 10px; left: 10px;
            width: 340px; background: rgba(255, 255, 255, 0.95);
            padding: 15px; border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.15);
            max-height: 85vh; overflow-y: auto;
            z-index: 10;
            font-size: 14px;
            display: none; 
        }
        @media (max-width: 600px) {
            #ui-panel { width: 90%; left: 5%; top: 10px; max-height: 60vh; }
        }

        h2 { margin-top: 0; font-size: 18px; color: #333; border-bottom: 2px solid #007bff; padding-bottom: 8px; margin-bottom: 15px;}
        
        .tab-container { display: flex; margin-bottom: 15px; border-bottom: 1px solid #ddd; }
        .tab-btn {
            flex: 1; padding: 8px 4px; text-align: center; cursor: pointer;
            background: #f8f9fa; border: 1px solid #ddd; border-bottom: none;
            margin-right: 2px; border-radius: 4px 4px 0 0; color: #666; font-size: 12px; white-space: nowrap;
        }
        .tab-btn.active { background: #fff; font-weight: bold; color: #007bff; border-bottom: 2px solid #fff; margin-bottom: -1px; }
        
        .mode-content { display: none; }
        .mode-content.active { display: block; }

        .control-group { margin-bottom: 15px; padding-bottom: 10px; border-bottom: 1px solid #eee; }
        .control-group:last-child { border-bottom: none; }
        
        label { display: block; margin-bottom: 5px; font-weight: bold; color: #444; cursor: pointer; }
        .checkbox-label { font-weight: normal; display: flex; align-items: center; gap: 5px; margin-bottom: 5px; }

        button {
            width: 100%; padding: 10px; margin-bottom: 8px;
            background-color: #007bff; color: white; border: none;
            border-radius: 4px; cursor: pointer; transition: background 0.2s;
        }
        button:hover { background-color: #0056b3; }
        button.secondary { background-color: #6c757d; }
        button.secondary:hover { background-color: #545b62; }
        button.danger { background-color: #dc3545; }
        button:disabled { background-color: #ccc; cursor: not-allowed; opacity: 0.7; }
        
        /* iOSç”¨ãƒœã‚¿ãƒ³ */
        #ios-ar-btn {
            background-color: #28a745; display: none; margin-top: 10px;
        }
        #ios-ar-btn:hover { background-color: #218838; }

        select { width: 100%; padding: 8px; border-radius: 4px; border: 1px solid #ccc; }
        input[type=range] { width: 100%; cursor: pointer; }
        .value-display { float: right; font-weight: normal; font-family: monospace; }
        .hint-text { font-size: 12px; color: #666; margin-top: -2px; margin-bottom: 8px; line-height: 1.4; }
        
        .debug-info {
            font-size: 12px; background: #e2e3e5; padding: 10px; border-radius: 5px; color: #383d41; margin-bottom: 10px;
        }
    </style>
    
    <script>
        window.addEventListener('error', function(e) {
            const overlay = document.getElementById('loading-overlay');
            const msg = document.getElementById('error-message');
            if(overlay && msg) {
                if (e.message && (e.message.includes('xr') || e.message.includes('XR'))) return;
                overlay.style.display = 'flex';
                msg.style.display = 'block';
                msg.innerHTML = '<strong>ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ:</strong><br>' + e.message + '<br><br>ãƒšãƒ¼ã‚¸ã‚’å†èª­ã¿è¾¼ã¿ã—ã¦ã¿ã¦ãã ã•ã„ã€‚';
            }
        });
    </script>
</head>
<body>

<div id="loading-overlay">
    <div id="status-text">ã‚·ã‚¹ãƒ†ãƒ èª­ã¿è¾¼ã¿ä¸­...</div>
    <div id="error-message"></div>
</div>

<div id="canvas-container">
    <div id="labels-container"></div>
</div>

<div id="ui-panel">
    <h2>ç«‹ä½“åˆ‡æ–­ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ãƒ¼ v15</h2>

    <div class="control-group">
        <label>å›³å½¢é¸æŠ</label>
        <select id="shape-select">
            <option value="cube">ç«‹æ–¹ä½“</option>
            <option value="prism">æ­£å››è§’æŸ±</option>
            <option value="pyramid">æ­£å››è§’éŒ</option>
            <option value="tri_pyramid">æ­£ä¸‰è§’éŒ</option>
            <option value="cylinder">å††æŸ±</option>
        </select>
        <button id="reset-btn" class="secondary" style="margin-top:5px; padding:6px;">å›³å½¢ã‚’ãƒªã‚»ãƒƒãƒˆ</button>
    </div>

    <div class="tab-container">
        <div class="tab-btn active" onclick="switchMode('slider')">â‘  ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼</div>
        <div class="tab-btn" onclick="switchMode('points')">â‘¡ ç‚¹æŒ‡å®š</div>
        <div class="tab-btn" onclick="switchMode('ar')">â‘¢ ARã§ç¢ºèª</div>
    </div>

    <div id="mode-slider" class="mode-content active">
        <div id="slider-controls-wrapper">
            <div class="control-group">
                <label>åˆ‡æ–­é¢ã®èª¿æ•´</label>
                <label>é«˜ã• (Y) <span id="val-y" class="value-display">0.00</span></label>
                <input type="range" id="cut-y" min="-3" max="3" step="0.01" value="0">
                <label>å›è»¢ (X:æ‰‹å‰å¥¥) <span id="val-rx" class="value-display">0Â°</span></label>
                <input type="range" id="cut-rx" min="-180" max="180" step="1" value="0">
                <label>å›è»¢ (Z:å·¦å³) <span id="val-rz" class="value-display">0Â°</span></label>
                <input type="range" id="cut-rz" min="-180" max="180" step="1" value="0">
                <button class="secondary" id="reset-slider-btn" style="font-size:12px; padding:5px; margin-top:5px;">è§’åº¦ã‚’æ°´å¹³ã«æˆ»ã™</button>
            </div>
        </div>
    </div>

    <div id="mode-points" class="mode-content">
        <div class="control-group">
            <label>åˆ‡æ–­ç‚¹ã®é¸æŠ</label>
            <p class="hint-text">â— <b>é ‚ç‚¹</b> (å¤§) / â— <b>ä¸­ç‚¹ãƒ»3ç­‰åˆ†ç‚¹</b> (å°)</p>
            <div style="display:flex; gap:5px;">
                <button id="clear-points-btn" class="danger" style="font-size:12px;">é¸æŠã‚¯ãƒªã‚¢</button>
            </div>
            <p id="points-count-display" style="font-weight:bold; color:#007bff; margin:5px 0;">é¸æŠæ•°: 0ç‚¹</p>
        </div>
    </div>

    <div id="mode-ar" class="mode-content">
        <div class="control-group">
            <label>ARï¼ˆæ‹¡å¼µç¾å®Ÿï¼‰ãƒ¢ãƒ¼ãƒ‰</label>
            
            <div id="ar-debug-info" class="debug-info">è¨ºæ–­ä¸­...</div>

            <div id="webxr-instructions" style="display:none;">
                <p class="hint-text">
                    1. ä¸‹ã® <b>[START AR]</b> ã‚’æŠ¼ã™<br>
                    2. åºŠã‚„æœºã‚’æ˜ ã—ã€ç™½ã„ãƒªãƒ³ã‚°ãŒå‡ºãŸã‚‰ã‚¿ãƒƒãƒ—
                </p>
            </div>

            <button id="ios-ar-btn">ğŸ“± AR Quick Look (iOS)</button>
            <p id="ios-hint" class="hint-text" style="display:none;">
                ãƒœã‚¿ãƒ³ã‚’æŠ¼ã™ã¨ã€ç¾åœ¨ã®å›³å½¢ã‚’ARãƒ•ã‚¡ã‚¤ãƒ«ã«å¤‰æ›ã—ã¦è¡¨ç¤ºã—ã¾ã™ã€‚(ã‚«ãƒ¡ãƒ©è¨±å¯ã¯ä¸è¦ã§ã™)
            </p>
        </div>
    </div>

    <div class="control-group">
        <label>åˆ‡æ–­å®Ÿè¡Œ</label>
        <button id="cut-btn">âœ‚ï¸ åˆ‡æ–­ (åŸºæœ¬)</button>
        <button id="cut-btn-inverse">âœ‚ï¸ åˆ‡æ–­ (é€†å´ã‚’æ®‹ã™)</button>
    </div>

    <div class="control-group">
        <button id="undo-btn" class="secondary" disabled>â†©ï¸ ã²ã¨ã¤æˆ»ã‚‹ (Undo)</button>
        <div style="margin-top:15px; padding-top:10px; border-top:1px solid #ddd;">
             <label style="font-size:12px; margin-bottom:8px; color:#666;">â–¼ è¡¨ç¤ºã‚ªãƒ—ã‚·ãƒ§ãƒ³</label>
             <label class="checkbox-label"><input type="checkbox" id="wireframe-check"> ãƒ¯ã‚¤ãƒ¤ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ ã®ã¿</label>
             <label class="checkbox-label"><input type="checkbox" id="grid-visible-check" checked> ã‚°ãƒªãƒƒãƒ‰ãƒ»è»¸ã‚’è¡¨ç¤º</label>
             <label class="checkbox-label"><input type="checkbox" id="labels-visible-check" checked> é ‚ç‚¹ãƒ©ãƒ™ãƒ«(A,B..)ã‚’è¡¨ç¤º</label>
             <hr style="border:0; border-top:1px dashed #eee; margin:5px 0;">
             <label class="checkbox-label"><input type="checkbox" id="plane-visible-check" checked> é’ã„åˆ‡æ–­é¢ã‚’è¡¨ç¤º</label>
             <label class="checkbox-label"><input type="checkbox" id="slider-visible-check" checked> ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼æ“ä½œãƒ‘ãƒãƒ«ã‚’è¡¨ç¤º</label>
        </div>
    </div>
</div>

<script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
            "three-mesh-bvh": "https://unpkg.com/three-mesh-bvh@0.7.0/build/index.module.js",
            "three-bvh-csg": "https://unpkg.com/three-bvh-csg@0.0.16/build/index.module.js"
        }
    }
</script>

<script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { ARButton } from 'three/addons/webxr/ARButton.js';
    import { USDZExporter } from 'three/addons/exporters/USDZExporter.js'; // iOSç”¨ã‚¨ã‚¯ã‚¹ãƒãƒ¼ã‚¿ãƒ¼
    import { SUBTRACTION, Brush, Evaluator } from 'three-bvh-csg';

    const overlay = document.getElementById('loading-overlay');
    if(overlay) overlay.style.display = 'none';
    document.getElementById('ui-panel').style.display = 'block';

    // --- ç’°å¢ƒåˆ¤å®šãƒ­ã‚¸ãƒƒã‚¯ ---
    let isWebXRAvailable = ('xr' in navigator);
    const isIos = /iPhone|iPad|iPod/i.test(navigator.userAgent);
    
    function checkAREnvironment() {
        const debugEl = document.getElementById('ar-debug-info');
        const webxrInst = document.getElementById('webxr-instructions');
        const iosBtn = document.getElementById('ios-ar-btn');
        const iosHint = document.getElementById('ios-hint');

        let html = "";

        if (isWebXRAvailable && !isIos) {
            // Android / WebXRå¯¾å¿œPC
            html += "ç«¯æœ«: WebXRå¯¾å¿œ (Androidç­‰)<br>ARãƒœã‚¿ãƒ³ã‚’è¡¨ç¤ºã—ã¾ã™ã€‚";
            webxrInst.style.display = 'block';
            return 'webxr';
        } else if (isIos) {
            // iOS (Safari)
            html += "ç«¯æœ«: iOS (iPhone/iPad)<br><b>AR Quick Look</b> ãƒ¢ãƒ¼ãƒ‰ã§å‹•ä½œã—ã¾ã™ã€‚<br>ä¸‹ã®ç·‘ã®ãƒœã‚¿ãƒ³ã‚’æŠ¼ã™ã¨ARãƒ“ãƒ¥ãƒ¼ã‚¢ãƒ¼ãŒèµ·å‹•ã—ã¾ã™ã€‚";
            iosBtn.style.display = 'block';
            iosHint.style.display = 'block';
            return 'ios';
        } else {
            // éå¯¾å¿œPC
            html += "ç«¯æœ«: ARéå¯¾å¿œ (PCç­‰)<br>ã“ã®ç«¯æœ«ã§ã¯ARæ©Ÿèƒ½ã¯ä½¿ç”¨ã§ãã¾ã›ã‚“ã€‚<br>ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼æ“ä½œç­‰ã¯å¯èƒ½ã§ã™ã€‚";
            return 'none';
        }
        debugEl.innerHTML = html;
    }

    const arMode = checkAREnvironment();
    // ------------------------

    const container = document.getElementById('canvas-container');
    const labelsContainer = document.getElementById('labels-container');
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xfafafa);

    const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
    camera.position.set(6, 5, 8);

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    if (isWebXRAvailable) renderer.xr.enabled = true; 
    container.appendChild(renderer.domElement);

    // WebXRãƒœã‚¿ãƒ³ (Androidç”¨)
    let webXrButton = null;
    if (arMode === 'webxr') {
        try {
            webXrButton = ARButton.createButton(renderer, { 
                requiredFeatures: ['hit-test'],
                optionalFeatures: ['dom-overlay'],
                domOverlay: { root: document.getElementById('ui-panel') } 
            });
            document.body.appendChild(webXrButton);
            webXrButton.style.display = 'none';
        } catch(e) {}
    }

    // iOS Quick Lookãƒœã‚¿ãƒ³å‡¦ç†
    document.getElementById('ios-ar-btn').addEventListener('click', async () => {
        if (!currentShapeBrush) return;
        
        const btn = document.getElementById('ios-ar-btn');
        btn.innerText = "ARãƒ•ã‚¡ã‚¤ãƒ«ã‚’ç”Ÿæˆä¸­...";
        btn.disabled = true;

        try {
            const exporter = new USDZExporter();
            // currentShapeBrushã ã‘ã‚’ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã™ã‚‹
            // ã‚µã‚¤ã‚ºãŒ3mã ã¨ãƒ‡ã‚«ã™ãã‚‹ã®ã§ã€ä¸€æ™‚çš„ã«ã‚¯ãƒ­ãƒ¼ãƒ³ã—ã¦å°ã•ãã™ã‚‹
            const clone = currentShapeBrush.clone();
            clone.scale.set(0.05, 0.05, 0.05); // å“ä¸Šã‚µã‚¤ã‚ºã«
            clone.rotation.x = -Math.PI / 2;   // å‘ãèª¿æ•´(USDZã®åº§æ¨™ç³»ç”¨)
            clone.updateMatrixWorld();

            const arraybuffer = await exporter.parse( clone );
            const blob = new Blob( [ arraybuffer ], { type: 'model/vnd.usdz+zip' } );
            const url = URL.createObjectURL( blob );

            // ãƒªãƒ³ã‚¯ã‚’ä½œæˆã—ã¦ã‚¯ãƒªãƒƒã‚¯ï¼ˆAR Quick Lookèµ·å‹•ï¼‰
            const link = document.createElement( 'a' );
            link.rel = 'ar';
            link.href = url;
            // ã‚¢ã‚¤ã‚³ãƒ³ç”¨ç”»åƒï¼ˆãƒ€ãƒŸãƒ¼ã§ã‚‚å‹•ããŒæ¨å¥¨ï¼‰
            const img = document.createElement('img');
            link.appendChild(img);
            
            link.click();

            btn.innerText = "ğŸ“± AR Quick Look (iOS)";
            btn.disabled = false;

        } catch(err) {
            alert("ARç”Ÿæˆã‚¨ãƒ©ãƒ¼: " + err.message);
            btn.innerText = "ã‚¨ãƒ©ãƒ¼ç™ºç”Ÿ";
            btn.disabled = false;
        }
    });

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;

    const ambientLight = new THREE.AmbientLight(0xffffff, 2.5); 
    scene.add(ambientLight);
    const dirLight = new THREE.DirectionalLight(0xffffff, 0.5);
    dirLight.position.set(5, 10, 7);
    dirLight.castShadow = true;
    scene.add(dirLight);
    const fillLight = new THREE.DirectionalLight(0xffffff, 0.5);
    fillLight.position.set(-5, 0, -5);
    scene.add(fillLight);

    let contentGroup = new THREE.Group();
    scene.add(contentGroup);

    let currentShapeBrush;    
    let materialStandard;     
    let historyStack = [];    
    let cutterGroup;
    let visualPlane;
    let invisibleCutterBrush;
    let currentMode = 'slider'; 
    let interactionObjects = []; 
    let selectedPoints = [];     
    let pointMarkers = [];       
    let raycaster = new THREE.Raycaster();
    let mouse = new THREE.Vector2();
    let hoveredObject = null;    
    let helperGroup = new THREE.Group();
    contentGroup.add(helperGroup);
    let vertexLabels = []; 
    let gridHelper, axesHelper;
    const evaluator = new Evaluator();
    let reticle;
    let hitTestSource = null;
    let hitTestSourceRequested = false;

    materialStandard = new THREE.MeshStandardMaterial({ 
        color: 0x66ccff, roughness: 0.5, metalness: 0.0, transparent: true, opacity: 0.9, side: THREE.DoubleSide,
    });

    init();

    function init() {
        try {
            gridHelper = new THREE.GridHelper(20, 20, 0xcccccc, 0xe5e5e5);
            contentGroup.add(gridHelper);
            axesHelper = new THREE.AxesHelper(5);
            contentGroup.add(axesHelper);
            setupCutterSystem();
            createShape('cube');
            updateCutterTransform();
            reticle = new THREE.Mesh(new THREE.RingGeometry(0.15, 0.2, 32).rotateX(-Math.PI / 2), new THREE.MeshBasicMaterial({ color: 0xffffff }));
            reticle.matrixAutoUpdate = false;
            reticle.visible = false;
            scene.add(reticle); 
            window.addEventListener('resize', onWindowResize);
            renderer.domElement.addEventListener('pointermove', onPointerMove); 
            renderer.domElement.addEventListener('pointerdown', onPointerDown); 
            if (isWebXRAvailable) {
                renderer.xr.addEventListener('sessionstart', onSessionStart);
                renderer.xr.addEventListener('sessionend', onSessionEnd);
            }
            renderer.setAnimationLoop(render); 
        } catch (e) { console.error(e); }
    }

    function onSessionStart() {
        contentGroup.scale.set(0.05, 0.05, 0.05);
        scene.background = null; 
    }
    function onSessionEnd() {
        contentGroup.scale.set(1, 1, 1);
        contentGroup.position.set(0, 0, 0);
        contentGroup.rotation.set(0, 0, 0);
        scene.background = new THREE.Color(0xfafafa);
        reticle.visible = false;
        hitTestSource = null;
        hitTestSourceRequested = false;
    }
    function setupCutterSystem() {
        cutterGroup = new THREE.Group();
        contentGroup.add(cutterGroup); 
        const planeGeo = new THREE.PlaneGeometry(12, 12);
        const planeMat = new THREE.MeshBasicMaterial({ color: 0x007bff, opacity: 0.2, transparent: true, side: THREE.DoubleSide, depthWrite: false });
        visualPlane = new THREE.Mesh(planeGeo, planeMat);
        visualPlane.rotation.x = -Math.PI / 2;
        const edges = new THREE.EdgesGeometry(planeGeo);
        const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0x0000ff, opacity: 0.3, transparent:true }));
        visualPlane.add(line);
        cutterGroup.add(visualPlane);
        const boxSize = 30;
        const boxGeo = new THREE.BoxGeometry(boxSize, boxSize, boxSize);
        boxGeo.translate(0, boxSize / 2, 0); 
        invisibleCutterBrush = new Brush(boxGeo, new THREE.MeshBasicMaterial({ visible: false }));
        cutterGroup.add(invisibleCutterBrush);
    }
    function createShape(type) {
        let geometry;
        switch(type) {
            case 'cube': geometry = new THREE.BoxGeometry(3, 3, 3); break;
            case 'prism': geometry = new THREE.BoxGeometry(2, 4, 2); break;
            case 'pyramid': geometry = new THREE.ConeGeometry(2, 3.5, 4); break;
            case 'tri_pyramid': geometry = new THREE.ConeGeometry(2, 3.5, 3); break;
            case 'cylinder': geometry = new THREE.CylinderGeometry(1.5, 1.5, 4, 32); break;
        }
        if (currentShapeBrush) contentGroup.remove(currentShapeBrush);
        currentShapeBrush = new Brush(geometry, materialStandard);
        currentShapeBrush.castShadow = true;
        currentShapeBrush.receiveShadow = true;
        contentGroup.add(currentShapeBrush);
        historyStack = [];
        createSnapPoints(geometry, currentShapeBrush);
        createLabels(geometry, currentShapeBrush); 
        updateUI(); 
    }
    function updateUI() {
        const undoBtn = document.getElementById('undo-btn');
        if (undoBtn) undoBtn.disabled = (historyStack.length === 0);
    }
    function createLabels(geometry, mesh) {
        vertexLabels.forEach(l => l.element.remove());
        vertexLabels = [];
        if (!document.getElementById('labels-visible-check').checked) return;
        const posAttr = geometry.attributes.position;
        const uniquePoints = [];
        const threshold = 0.01;
        for (let i = 0; i < posAttr.count; i++) {
            const v = new THREE.Vector3().fromBufferAttribute(posAttr, i);
            let exists = false;
            for (let p of uniquePoints) {
                if (p.distanceTo(v) < threshold) { exists = true; break; }
            }
            if (!exists) uniquePoints.push(v);
        }
        uniquePoints.sort((a, b) => {
            if (Math.abs(b.y - a.y) > 0.1) return b.y - a.y; 
            if (Math.abs(b.x - a.x) > 0.1) return a.x - b.x; 
            return a.z - b.z;
        });
        const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
        uniquePoints.forEach((localPos, index) => {
            if (index >= chars.length) return;
            const labelText = chars[index];
            const div = document.createElement('div');
            div.className = 'vertex-label';
            div.innerText = labelText;
            labelsContainer.appendChild(div);
            vertexLabels.push({ element: div, localPos: localPos.clone(), mesh: mesh });
        });
    }
    function updateLabels() {
        if (vertexLabels.length === 0) return;
        const isVisible = document.getElementById('labels-visible-check').checked;
        if (!isVisible) { vertexLabels.forEach(l => l.element.style.display = 'none'); return; }
        const widthHalf = window.innerWidth / 2;
        const heightHalf = window.innerHeight / 2;
        vertexLabels.forEach(label => {
            const worldPos = label.localPos.clone().applyMatrix4(label.mesh.matrixWorld);
            const pos = worldPos.clone();
            pos.project(camera);
            if (pos.z > 1) { label.element.style.display = 'none'; } else {
                label.element.style.display = 'block';
                const x = (pos.x * widthHalf) + widthHalf;
                const y = -(pos.y * heightHalf) + heightHalf;
                label.element.style.left = `${x}px`;
                label.element.style.top = `${y}px`;
            }
        });
    }
    function createSnapPoints(geometry, mesh) {
        helperGroup.clear();
        interactionObjects = [];
        const addedPoints = new Set(); 
        function addSnapSphere(pos, type) {
            const key = `${pos.x.toFixed(3)},${pos.y.toFixed(3)},${pos.z.toFixed(3)}`;
            if (addedPoints.has(key)) return;
            addedPoints.add(key);
            const size = (type === 'vertex') ? 0.15 : 0.08;
            const color = (type === 'vertex') ? 0x333333 : 0x666666;
            const opacity = (type === 'vertex') ? 0.6 : 0.4;
            const geo = new THREE.SphereGeometry(size, 16, 16);
            const mat = new THREE.MeshBasicMaterial({ color: color, transparent: true, opacity: opacity });
            const sphere = new THREE.Mesh(geo, mat);
            sphere.position.copy(pos);
            sphere.userData = { isSnapPoint: true, originalColor: color, hoverColor: 0xffaa00, pos: pos.clone() };
            helperGroup.add(sphere);
            interactionObjects.push(sphere);
        }
        const posAttr = geometry.attributes.position;
        for(let i=0; i<posAttr.count; i++){ addSnapSphere(new THREE.Vector3().fromBufferAttribute(posAttr, i), 'vertex'); }
        const edgesGeo = new THREE.EdgesGeometry(geometry, 20); 
        const edgePos = edgesGeo.attributes.position;
        for (let i = 0; i < edgePos.count; i += 2) {
            const start = new THREE.Vector3().fromBufferAttribute(edgePos, i);
            const end = new THREE.Vector3().fromBufferAttribute(edgePos, i + 1);
            addSnapSphere(start.clone().lerp(end, 0.5), 'sub');
            addSnapSphere(start.clone().lerp(end, 1/3), 'sub');
            addSnapSphere(start.clone().lerp(end, 2/3), 'sub');
        }
    }
    function onPointerMove(event) {
        if (currentMode !== 'points') return;
        if (renderer.xr.isPresenting) return; 
        updateMouse(event);
        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects(interactionObjects);
        if (intersects.length > 0) {
            const obj = intersects[0].object;
            if (hoveredObject !== obj) {
                if (hoveredObject) hoveredObject.material.color.setHex(hoveredObject.userData.originalColor);
                hoveredObject = obj;
                hoveredObject.material.color.setHex(obj.userData.hoverColor);
                document.body.style.cursor = 'pointer';
            }
        } else {
            if (hoveredObject) {
                hoveredObject.material.color.setHex(hoveredObject.userData.originalColor);
                hoveredObject = null;
                document.body.style.cursor = 'default';
            }
        }
    }
    if (isWebXRAvailable) {
        const controller = renderer.xr.getController(0);
        controller.addEventListener('select', function() {
            if (reticle.visible) {
                reticle.matrix.decompose(contentGroup.position, contentGroup.quaternion, contentGroup.scale);
                contentGroup.scale.set(0.05, 0.05, 0.05); 
            }
        });
        scene.add(controller);
    }
    function onPointerDown(event) {
        if (!renderer.xr.isPresenting && currentMode === 'points') {
            if (!hoveredObject) return; 
            addSelectedPoint(hoveredObject.userData.pos);
        }
    }
    function updateMouse(event) {
        const rect = renderer.domElement.getBoundingClientRect();
        mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
        mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
    }
    function addSelectedPoint(pos) {
        selectedPoints.push(pos.clone());
        const markerGeo = new THREE.SphereGeometry(0.18, 16, 16); 
        const markerMat = new THREE.MeshBasicMaterial({ color: 0xff0000 });
        const marker = new THREE.Mesh(markerGeo, markerMat);
        marker.position.copy(pos);
        contentGroup.add(marker); 
        pointMarkers.push(marker);
        updatePointCountUI();
        if (selectedPoints.length >= 3) alignCutterToPoints();
    }
    function clearPoints() {
        selectedPoints = [];
        pointMarkers.forEach(m => contentGroup.remove(m));
        pointMarkers = [];
        updatePointCountUI();
    }
    function updatePointCountUI() {
        const el = document.getElementById('points-count-display');
        el.innerText = `é¸æŠæ•°: ${selectedPoints.length}ç‚¹`;
        el.style.color = selectedPoints.length >= 3 ? '#28a745' : '#007bff';
    }
    function alignCutterToPoints() {
        if (selectedPoints.length < 3) return;
        const p1 = selectedPoints[0];
        const p2 = selectedPoints[1];
        const p3 = selectedPoints[2];
        const plane = new THREE.Plane();
        plane.setFromCoplanarPoints(p1, p2, p3);
        const coplanarPoint = plane.normal.clone().multiplyScalar(-plane.constant);
        cutterGroup.position.copy(coplanarPoint);
        const defaultNormal = new THREE.Vector3(0, 1, 0);
        const targetNormal = plane.normal.clone();
        const quaternion = new THREE.Quaternion();
        quaternion.setFromUnitVectors(defaultNormal, targetNormal);
        cutterGroup.setRotationFromQuaternion(quaternion);
        cutterGroup.updateMatrixWorld();
    }
    function updateCutterTransform() {
        if (currentMode !== 'slider') return; 
        const y = parseFloat(document.getElementById('cut-y').value);
        const rx = parseFloat(document.getElementById('cut-rx').value);
        const rz = parseFloat(document.getElementById('cut-rz').value);
        cutterGroup.position.set(0, y, 0);
        cutterGroup.rotation.set(THREE.MathUtils.degToRad(rx), 0, THREE.MathUtils.degToRad(rz));
        document.getElementById('val-y').innerText = y.toFixed(2);
        document.getElementById('val-rx').innerText = rx + "Â°";
        document.getElementById('val-rz').innerText = rz + "Â°";
    }
    function performCut(inverse) {
        if (!currentShapeBrush) return;
        const historyGeometry = currentShapeBrush.geometry.clone();
        historyStack.push({ geo: historyGeometry });
        try {
            invisibleCutterBrush.updateMatrixWorld();
            invisibleCutterBrush.scale.y = inverse ? -1 : 1;
            invisibleCutterBrush.updateMatrixWorld();
            const resultBrush = evaluator.evaluate(currentShapeBrush, invisibleCutterBrush, SUBTRACTION);
            contentGroup.remove(currentShapeBrush);
            currentShapeBrush = resultBrush;
            updateMaterial();
            currentShapeBrush.castShadow = true;
            currentShapeBrush.receiveShadow = true;
            contentGroup.add(currentShapeBrush);
            invisibleCutterBrush.scale.y = 1;
            clearPoints();
            helperGroup.visible = false;
            createLabels(currentShapeBrush.geometry, currentShapeBrush);
        } catch (err) { console.error("Cut failed:", err); }
        updateUI();
    }
    function undo() {
        if (historyStack.length === 0) return;
        const state = historyStack.pop();
        contentGroup.remove(currentShapeBrush);
        currentShapeBrush = new Brush(state.geo, materialStandard);
        updateMaterial();
        currentShapeBrush.castShadow = true;
        currentShapeBrush.receiveShadow = true;
        contentGroup.add(currentShapeBrush);
        if (historyStack.length === 0) { 
             createShape(document.getElementById('shape-select').value);
        } else {
             helperGroup.visible = false;
             createLabels(currentShapeBrush.geometry, currentShapeBrush);
        }
        updateUI();
    }
    function updateMaterial() {
        const isWire = document.getElementById('wireframe-check').checked;
        if (isWire) {
            currentShapeBrush.material = new THREE.MeshBasicMaterial({ wireframe: true, color: 0x333333 });
        } else {
            currentShapeBrush.material = materialStandard;
        }
    }
    document.getElementById('grid-visible-check').addEventListener('change', (e) => {
        gridHelper.visible = e.target.checked;
        axesHelper.visible = e.target.checked;
    });
    document.getElementById('slider-visible-check').addEventListener('change', (e) => {
        const wrapper = document.getElementById('slider-controls-wrapper');
        wrapper.style.display = e.target.checked ? 'block' : 'none';
    });
    document.getElementById('plane-visible-check').addEventListener('change', (e) => {
        visualPlane.visible = e.target.checked;
    });
    document.getElementById('labels-visible-check').addEventListener('change', (e) => {
        if(e.target.checked) { createLabels(currentShapeBrush.geometry, currentShapeBrush); } else { vertexLabels.forEach(l => l.element.style.display = 'none'); }
    });
    window.switchMode = function(mode) {
        currentMode = mode;
        document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
        document.querySelectorAll('.mode-content').forEach(c => c.classList.remove('active'));
        if(mode === 'ar') {
            const d = document.getElementById('ar-debug-info');
            if (d) d.innerHTML = (arMode === 'ios') ? "ãƒ¢ãƒ¼ãƒ‰: iOS Quick Look (æœ‰åŠ¹)" : (arMode === 'webxr') ? "ãƒ¢ãƒ¼ãƒ‰: WebXR (æœ‰åŠ¹)" : "ARéå¯¾å¿œã®ç«¯æœ«ã§ã™ã€‚";
            if (arMode === 'webxr' && webXrButton) webXrButton.style.display = 'block';
            if (arMode === 'ios') { 
                document.getElementById('ios-ar-btn').style.display = 'block'; 
                document.getElementById('ios-hint').style.display = 'block';
            }
            document.querySelector('.tab-btn:nth-child(3)').classList.add('active');
            document.getElementById('mode-ar').classList.add('active');
            helperGroup.visible = false;
        } else {
            if (webXrButton) webXrButton.style.display = 'none'; 
            document.getElementById('ios-ar-btn').style.display = 'none';
            document.getElementById('ios-hint').style.display = 'none';
            if(mode === 'slider') {
                document.querySelector('.tab-btn:nth-child(1)').classList.add('active');
                document.getElementById('mode-slider').classList.add('active');
                helperGroup.visible = false;
            } else if (mode === 'points') {
                document.querySelector('.tab-btn:nth-child(2)').classList.add('active');
                document.getElementById('mode-points').classList.add('active');
                helperGroup.visible = true;
                if(historyStack.length === 0 && interactionObjects.length === 0) {
                    createSnapPoints(currentShapeBrush.geometry, currentShapeBrush);
                }
            }
        }
    };
    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }
    function render(timestamp, frame) {
        if (renderer.xr.isPresenting) {
            if (frame && hitTestSourceRequested === false) {
                const session = renderer.xr.getSession();
                session.requestReferenceSpace('viewer').then(function (referenceSpace) {
                    session.requestHitTestSource({ space: referenceSpace }).then(function (source) { hitTestSource = source; });
                });
                session.addEventListener('end', function () { hitTestSourceRequested = false; hitTestSource = null; });
                hitTestSourceRequested = true;
            }
            if (hitTestSource && frame) {
                const hitTestResults = frame.getHitTestResults(hitTestSource);
                if (hitTestResults.length > 0) {
                    const hit = hitTestResults[0];
                    const referenceSpace = renderer.xr.getReferenceSpace();
                    reticle.visible = true;
                    reticle.matrix.fromArray(hit.getPose(referenceSpace).transform.matrix);
                } else { reticle.visible = false; }
            }
        } else {
            controls.update();
            reticle.visible = false;
        }
        updateLabels();
        renderer.render(scene, camera);
    }

    document.getElementById('shape-select').addEventListener('change', (e) => createShape(e.target.value));
    ['cut-y', 'cut-rx', 'cut-rz'].forEach(id => document.getElementById(id).addEventListener('input', updateCutterTransform));
    document.getElementById('reset-slider-btn').addEventListener('click', () => {
        document.getElementById('cut-rx').value = 0; document.getElementById('cut-rz').value = 0; updateCutterTransform();
    });
    document.getElementById('clear-points-btn').addEventListener('click', clearPoints);
    document.getElementById('cut-btn').addEventListener('click', () => performCut(false));
    document.getElementById('cut-btn-inverse').addEventListener('click', () => performCut(true));
    document.getElementById('undo-btn').addEventListener('click', undo);
    document.getElementById('reset-btn').addEventListener('click', () => createShape(document.getElementById('shape-select').value));
    document.getElementById('wireframe-check').addEventListener('change', updateMaterial);
</script>
</body>
</html>
