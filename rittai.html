<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>立体図形切断シミュレーター v5</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: "Helvetica Neue", Arial, sans-serif; background-color: #f0f0f0; }
        #canvas-container { width: 100vw; height: 100vh; }
        
        /* UIパネル */
        #ui-panel {
            position: absolute; top: 10px; left: 10px;
            width: 340px; background: rgba(255, 255, 255, 0.95);
            padding: 15px; border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.15);
            max-height: 95vh; overflow-y: auto;
            z-index: 10;
            font-size: 14px;
        }
        h2 { margin-top: 0; font-size: 18px; color: #333; border-bottom: 2px solid #007bff; padding-bottom: 8px; margin-bottom: 15px;}
        
        .tab-container { display: flex; margin-bottom: 15px; border-bottom: 1px solid #ddd; }
        .tab-btn {
            flex: 1; padding: 8px; text-align: center; cursor: pointer;
            background: #f8f9fa; border: 1px solid #ddd; border-bottom: none;
            margin-right: 2px; border-radius: 4px 4px 0 0; color: #666; font-size: 12px;
        }
        .tab-btn.active { background: #fff; font-weight: bold; color: #007bff; border-bottom: 2px solid #fff; margin-bottom: -1px; }
        
        .mode-content { display: none; }
        .mode-content.active { display: block; }

        .control-group { margin-bottom: 15px; padding-bottom: 10px; border-bottom: 1px solid #eee; }
        .control-group:last-child { border-bottom: none; }
        
        label { display: block; margin-bottom: 5px; font-weight: bold; color: #444; }
        button {
            width: 100%; padding: 10px; margin-bottom: 8px;
            background-color: #007bff; color: white; border: none;
            border-radius: 4px; cursor: pointer; transition: background 0.2s;
        }
        button:hover { background-color: #0056b3; }
        button.secondary { background-color: #6c757d; }
        button.secondary:hover { background-color: #545b62; }
        button.danger { background-color: #dc3545; }
        button:disabled { background-color: #ccc; cursor: not-allowed; opacity: 0.7; }
        
        select { width: 100%; padding: 8px; border-radius: 4px; border: 1px solid #ccc; }
        input[type=range] { width: 100%; cursor: pointer; }
        .value-display { float: right; font-weight: normal; font-family: monospace; }
        .hint-text { font-size: 12px; color: #666; margin-top: -2px; margin-bottom: 8px; line-height: 1.4; }
        
        #error-log {
            position: absolute; bottom: 10px; left: 10px;
            background: rgba(200, 0, 0, 0.9); color: white;
            padding: 10px; border-radius: 5px; font-size: 12px;
            max-width: 400px; display: none; pointer-events: none;
        }
    </style>
</head>
<body>

<div id="canvas-container"></div>
<div id="error-log"></div>

<div id="ui-panel">
    <h2>立体切断シミュレーター v5</h2>

    <div class="control-group">
        <label>図形選択</label>
        <select id="shape-select">
            <option value="cube">立方体</option>
            <option value="prism">正四角柱</option>
            <option value="pyramid">正四角錐</option>
            <option value="tri_pyramid">正三角錐</option>
            <option value="cylinder">円柱</option>
        </select>
        <button id="reset-btn" class="secondary" style="margin-top:5px; padding:6px;">図形をリセット</button>
    </div>

    <div class="tab-container">
        <div class="tab-btn active" onclick="switchMode('slider')">① スライダー</div>
        <div class="tab-btn" onclick="switchMode('points')">② 点指定(厳密)</div>
    </div>

    <div id="mode-slider" class="mode-content active">
        <div class="control-group">
            <label>切断面の調整</label>
            <label>高さ (Y) <span id="val-y" class="value-display">0.00</span></label>
            <input type="range" id="cut-y" min="-3" max="3" step="0.01" value="0">
            
            <label>回転 (X:手前奥) <span id="val-rx" class="value-display">0°</span></label>
            <input type="range" id="cut-rx" min="-180" max="180" step="1" value="0">
            
            <label>回転 (Z:左右) <span id="val-rz" class="value-display">0°</span></label>
            <input type="range" id="cut-rz" min="-180" max="180" step="1" value="0">
            <button class="secondary" id="reset-slider-btn" style="font-size:12px; padding:5px; margin-top:5px;">角度を水平に戻す</button>
        </div>
    </div>

    <div id="mode-points" class="mode-content">
        <div class="control-group">
            <label>切断点の選択</label>
            <p class="hint-text">
                以下の点のみ選択可能です：<br>
                ● <b>頂点</b> (大)<br>
                ● <b>中点・3等分点</b> (小)
            </p>
            
            <div style="display:flex; gap:5px;">
                <button id="clear-points-btn" class="danger" style="font-size:12px;">選択クリア</button>
            </div>
            <p id="points-count-display" style="font-weight:bold; color:#007bff; margin:5px 0;">選択数: 0点</p>
        </div>
    </div>

    <div class="control-group">
        <label>切断実行</label>
        <button id="cut-btn">✂️ 切断 (基本)</button>
        <button id="cut-btn-inverse">✂️ 切断 (逆側を残す)</button>
    </div>

    <div class="control-group">
        <button id="undo-btn" class="secondary" disabled>↩️ ひとつ戻る (Undo)</button>
        <div style="margin-top:10px;">
             <label style="font-weight:normal;"><input type="checkbox" id="wireframe-check"> ワイヤーフレーム表示</label>
        </div>
    </div>
</div>

<script type="importmap">
    {
        "imports": {
            "three": "https://esm.sh/three@0.160.0",
            "three/addons/": "https://esm.sh/three@0.160.0/examples/jsm/",
            "three-bvh-csg": "https://esm.sh/three-bvh-csg@0.0.16?deps=three@0.160.0"
        }
    }
</script>

<script type="module">
    window.onerror = function(message, source, lineno, colno, error) {
        const el = document.getElementById('error-log');
        el.style.display = 'block';
        el.innerHTML += `Error: ${message}<br><small>${source}:${lineno}</small><br>`;
    };

    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { SUBTRACTION, Brush, Evaluator } from 'three-bvh-csg';

    // 1. セットアップ
    const container = document.getElementById('canvas-container');
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xf5f5f5);

    const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
    camera.position.set(6, 5, 8);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    container.appendChild(renderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;

    const ambientLight = new THREE.AmbientLight(0x404040, 2.0);
    scene.add(ambientLight);
    const dirLight = new THREE.DirectionalLight(0xffffff, 2.0);
    dirLight.position.set(5, 10, 7);
    dirLight.castShadow = true;
    scene.add(dirLight);

    // 2. 変数定義
    let currentShapeBrush;    
    let materialStandard;     
    let historyStack = [];    
    
    let cutterGroup;
    let visualPlane;
    let invisibleCutterBrush;

    let currentMode = 'slider'; 
    let interactionObjects = []; // クリック可能な球体リスト
    let selectedPoints = [];     
    let pointMarkers = [];       
    let raycaster = new THREE.Raycaster();
    let mouse = new THREE.Vector2();
    let hoveredObject = null;    // マウスオーバー中のオブジェクト
    
    let helperGroup = new THREE.Group();
    scene.add(helperGroup);

    const evaluator = new Evaluator();

    // マテリアル（半透明化）
    materialStandard = new THREE.MeshStandardMaterial({ 
        color: 0x44aaff,
        roughness: 0.2,
        metalness: 0.1,
        transparent: true,
        opacity: 0.85, 
        side: THREE.DoubleSide,
    });

    // 3. 初期化
    init();

    function init() {
        try {
            const gridHelper = new THREE.GridHelper(20, 20, 0xcccccc, 0xe5e5e5);
            scene.add(gridHelper);

            setupCutterSystem();
            createShape('cube');
            updateCutterTransform();

            window.addEventListener('resize', onWindowResize);
            renderer.domElement.addEventListener('pointermove', onPointerMove); // ホバー用
            renderer.domElement.addEventListener('pointerdown', onPointerDown); // クリック用

            animate();
        } catch (e) {
            console.error(e);
        }
    }

    function setupCutterSystem() {
        cutterGroup = new THREE.Group();
        scene.add(cutterGroup);

        const planeGeo = new THREE.PlaneGeometry(12, 12);
        const planeMat = new THREE.MeshBasicMaterial({
            color: 0x007bff, opacity: 0.25, transparent: true, side: THREE.DoubleSide, depthWrite: false
        });
        visualPlane = new THREE.Mesh(planeGeo, planeMat);
        visualPlane.rotation.x = -Math.PI / 2;
        
        const edges = new THREE.EdgesGeometry(planeGeo);
        const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0x0000ff, opacity: 0.5, transparent:true }));
        visualPlane.add(line);
        cutterGroup.add(visualPlane);

        const boxSize = 30;
        const boxGeo = new THREE.BoxGeometry(boxSize, boxSize, boxSize);
        boxGeo.translate(0, boxSize / 2, 0); 
        invisibleCutterBrush = new Brush(boxGeo, new THREE.MeshBasicMaterial({ visible: false }));
        cutterGroup.add(invisibleCutterBrush);
    }

    function createShape(type) {
        let geometry;
        switch(type) {
            case 'cube': geometry = new THREE.BoxGeometry(3, 3, 3); break;
            case 'prism': geometry = new THREE.BoxGeometry(2, 4, 2); break;
            case 'pyramid': geometry = new THREE.ConeGeometry(2, 3.5, 4); break;
            case 'tri_pyramid': geometry = new THREE.ConeGeometry(2, 3.5, 3); break;
            case 'cylinder': geometry = new THREE.CylinderGeometry(1.5, 1.5, 4, 32); break;
        }

        if (currentShapeBrush) scene.remove(currentShapeBrush);
        
        currentShapeBrush = new Brush(geometry, materialStandard);
        currentShapeBrush.castShadow = true;
        currentShapeBrush.receiveShadow = true;
        scene.add(currentShapeBrush);
        
        historyStack = [];
        
        // スナップポイント（選択可能な点）の生成
        createSnapPoints(geometry, currentShapeBrush);
        
        updateUI();
    }

    // ============================
    // 4. スナップポイント生成 (重要)
    // ============================
    function createSnapPoints(geometry, mesh) {
        helperGroup.clear();
        interactionObjects = [];
        const addedPoints = new Set(); // 重複防止用

        // スフィアを作成して配置する内部関数
        // type: 'vertex' (大) or 'sub' (小)
        function addSnapSphere(pos, type) {
            // 座標をキーにして重複チェック
            const key = `${pos.x.toFixed(3)},${pos.y.toFixed(3)},${pos.z.toFixed(3)}`;
            if (addedPoints.has(key)) return;
            addedPoints.add(key);

            // サイズ決定: 頂点は大きく、途中点は小さく
            const size = (type === 'vertex') ? 0.15 : 0.08;
            const color = (type === 'vertex') ? 0x333333 : 0x666666;
            const opacity = (type === 'vertex') ? 0.6 : 0.4;

            const geo = new THREE.SphereGeometry(size, 16, 16);
            const mat = new THREE.MeshBasicMaterial({ color: color, transparent: true, opacity: opacity });
            const sphere = new THREE.Mesh(geo, mat);
            
            // ワールド座標に配置
            // (meshは初期位置(0,0,0)前提だが、汎用性のためMatrix適用)
            const worldPos = pos.clone().applyMatrix4(mesh.matrixWorld);
            sphere.position.copy(worldPos);
            
            sphere.userData = { 
                isSnapPoint: true, 
                originalColor: color,
                hoverColor: 0xffaa00,
                pos: worldPos.clone()
            };

            helperGroup.add(sphere);
            interactionObjects.push(sphere);
        }

        // A. 頂点の抽出と配置
        // ConeGeometryなどの場合、頂点配列を走査
        const posAttr = geometry.attributes.position;
        // 頂点の追加
        for(let i=0; i<posAttr.count; i++){
             const v = new THREE.Vector3().fromBufferAttribute(posAttr, i);
             addSnapSphere(v, 'vertex');
        }

        // B. 辺の抽出と中点・3等分点の計算
        // EdgesGeometryを使って「視覚的な辺」の両端を取得する
        // thresholdAngleを大きめにとって、主要な辺だけを拾う
        const edgesGeo = new THREE.EdgesGeometry(geometry, 20); 
        const edgePos = edgesGeo.attributes.position;

        for (let i = 0; i < edgePos.count; i += 2) {
            const start = new THREE.Vector3().fromBufferAttribute(edgePos, i);
            const end = new THREE.Vector3().fromBufferAttribute(edgePos, i + 1);

            // 1. 中点 (1/2)
            const mid = start.clone().lerp(end, 0.5);
            addSnapSphere(mid, 'sub');

            // 2. 3等分点 (1/3, 2/3)
            const tri1 = start.clone().lerp(end, 1/3);
            const tri2 = start.clone().lerp(end, 2/3);
            addSnapSphere(tri1, 'sub');
            addSnapSphere(tri2, 'sub');
        }
    }

    // ============================
    // 5. インタラクション
    // ============================
    function onPointerMove(event) {
        if (currentMode !== 'points') return;
        
        updateMouse(event);
        raycaster.setFromCamera(mouse, camera);
        
        const intersects = raycaster.intersectObjects(interactionObjects);
        
        // ホバーエフェクト
        if (intersects.length > 0) {
            const obj = intersects[0].object;
            if (hoveredObject !== obj) {
                // 前のを戻す
                if (hoveredObject) hoveredObject.material.color.setHex(hoveredObject.userData.originalColor);
                
                hoveredObject = obj;
                hoveredObject.material.color.setHex(obj.userData.hoverColor);
                document.body.style.cursor = 'pointer';
            }
        } else {
            if (hoveredObject) {
                hoveredObject.material.color.setHex(hoveredObject.userData.originalColor);
                hoveredObject = null;
                document.body.style.cursor = 'default';
            }
        }
    }

    function onPointerDown(event) {
        if (currentMode !== 'points') return;
        if (!hoveredObject) return; // ホバーしてなければ無視

        addSelectedPoint(hoveredObject.userData.pos);
    }

    function updateMouse(event) {
        const rect = renderer.domElement.getBoundingClientRect();
        mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
        mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
    }

    function addSelectedPoint(pos) {
        selectedPoints.push(pos.clone());

        // 選択確定マーカー（赤）
        const markerGeo = new THREE.SphereGeometry(0.18, 16, 16); // 少し大きく
        const markerMat = new THREE.MeshBasicMaterial({ color: 0xff0000 });
        const marker = new THREE.Mesh(markerGeo, markerMat);
        marker.position.copy(pos);
        scene.add(marker);
        pointMarkers.push(marker);

        updatePointCountUI();
        
        if (selectedPoints.length >= 3) {
            alignCutterToPoints();
        }
    }

    function clearPoints() {
        selectedPoints = [];
        pointMarkers.forEach(m => scene.remove(m));
        pointMarkers = [];
        updatePointCountUI();
    }
    
    function updatePointCountUI() {
        const el = document.getElementById('points-count-display');
        el.innerText = `選択数: ${selectedPoints.length}点`;
        el.style.color = selectedPoints.length >= 3 ? '#28a745' : '#007bff';
    }

    function alignCutterToPoints() {
        if (selectedPoints.length < 3) return;

        const p1 = selectedPoints[0];
        const p2 = selectedPoints[1];
        const p3 = selectedPoints[2];

        const plane = new THREE.Plane();
        plane.setFromCoplanarPoints(p1, p2, p3);

        const coplanarPoint = plane.normal.clone().multiplyScalar(-plane.constant);
        cutterGroup.position.copy(coplanarPoint);

        const defaultNormal = new THREE.Vector3(0, 1, 0);
        const targetNormal = plane.normal.clone();
        const quaternion = new THREE.Quaternion();
        quaternion.setFromUnitVectors(defaultNormal, targetNormal);
        cutterGroup.setRotationFromQuaternion(quaternion);
        cutterGroup.updateMatrixWorld();
    }

    // ============================
    // 6. 共通処理
    // ============================
    function updateCutterTransform() {
        if (currentMode !== 'slider') return; 

        const y = parseFloat(document.getElementById('cut-y').value);
        const rx = parseFloat(document.getElementById('cut-rx').value);
        const rz = parseFloat(document.getElementById('cut-rz').value);

        cutterGroup.position.set(0, y, 0);
        cutterGroup.rotation.set(
            THREE.MathUtils.degToRad(rx),
            0,
            THREE.MathUtils.degToRad(rz)
        );
        document.getElementById('val-y').innerText = y.toFixed(2);
        document.getElementById('val-rx').innerText = rx + "°";
        document.getElementById('val-rz').innerText = rz + "°";
    }

    function performCut(inverse) {
        if (!currentShapeBrush) return;

        const historyGeometry = currentShapeBrush.geometry.clone();
        historyStack.push({ geo: historyGeometry });

        try {
            invisibleCutterBrush.updateMatrixWorld();
            invisibleCutterBrush.scale.y = inverse ? -1 : 1;
            invisibleCutterBrush.updateMatrixWorld();

            const resultBrush = evaluator.evaluate(currentShapeBrush, invisibleCutterBrush, SUBTRACTION);
            
            scene.remove(currentShapeBrush);
            currentShapeBrush = resultBrush;
            
            updateMaterial();
            currentShapeBrush.castShadow = true;
            currentShapeBrush.receiveShadow = true;
            scene.add(currentShapeBrush);

            invisibleCutterBrush.scale.y = 1;
            
            // 切断後はスナップポイントを消去（形状変わるので）
            clearPoints();
            helperGroup.visible = false;

        } catch (err) {
            console.error("Cut failed:", err);
        }
        updateUI();
    }

    function undo() {
        if (historyStack.length === 0) return;
        const state = historyStack.pop();
        
        scene.remove(currentShapeBrush);
        currentShapeBrush = new Brush(state.geo, materialStandard);
        
        updateMaterial();
        currentShapeBrush.castShadow = true;
        currentShapeBrush.receiveShadow = true;
        scene.add(currentShapeBrush);
        
        if (historyStack.length === 0) { 
            // 初期状態に戻った
             createShape(document.getElementById('shape-select').value);
        } else {
             helperGroup.visible = false;
        }
        updateUI();
    }

    function updateMaterial() {
        if (document.getElementById('wireframe-check').checked) {
            currentShapeBrush.material = new THREE.MeshBasicMaterial({ wireframe: true, color: 0x333333 });
        } else {
            currentShapeBrush.material = materialStandard;
        }
    }

    window.switchMode = function(mode) {
        currentMode = mode;
        document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
        document.querySelectorAll('.mode-content').forEach(c => c.classList.remove('active'));
        
        if(mode === 'slider') {
            document.querySelector('.tab-btn:nth-child(1)').classList.add('active');
            document.getElementById('mode-slider').classList.add('active');
            helperGroup.visible = false;
        } else {
            document.querySelector('.tab-btn:nth-child(2)').classList.add('active');
            document.getElementById('mode-points').classList.add('active');
            helperGroup.visible = true;
            // ヘルパー再生成チェック
            if(historyStack.length === 0 && interactionObjects.length === 0) {
                createSnapPoints(currentShapeBrush.geometry, currentShapeBrush);
            }
        }
    };

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
        requestAnimationFrame(animate);
        controls.update();
        renderer.render(scene, camera);
    }

    function updateUI() {
        document.getElementById('undo-btn').disabled = (historyStack.length === 0);
    }

    // イベントリスナー
    document.getElementById('shape-select').addEventListener('change', (e) => createShape(e.target.value));
    ['cut-y', 'cut-rx', 'cut-rz'].forEach(id => document.getElementById(id).addEventListener('input', updateCutterTransform));
    document.getElementById('reset-slider-btn').addEventListener('click', () => {
        document.getElementById('cut-rx').value = 0; document.getElementById('cut-rz').value = 0; updateCutterTransform();
    });
    document.getElementById('clear-points-btn').addEventListener('click', clearPoints);
    document.getElementById('cut-btn').addEventListener('click', () => performCut(false));
    document.getElementById('cut-btn-inverse').addEventListener('click', () => performCut(true));
    document.getElementById('undo-btn').addEventListener('click', undo);
    document.getElementById('reset-btn').addEventListener('click', () => createShape(document.getElementById('shape-select').value));
    document.getElementById('wireframe-check').addEventListener('change', updateMaterial);
</script>
</body>
</html>
