<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>立体図形切断シミュレーター v2</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: sans-serif; background-color: #f0f0f0; }
        #canvas-container { width: 100vw; height: 100vh; }
        #ui-panel {
            position: absolute; top: 10px; left: 10px;
            width: 300px; background: rgba(255, 255, 255, 0.95);
            padding: 15px; border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            max-height: 90vh; overflow-y: auto;
            z-index: 10;
        }
        /* エラー表示エリア */
        #error-log {
            position: absolute; bottom: 10px; left: 10px;
            background: rgba(255, 0, 0, 0.8); color: white;
            padding: 10px; border-radius: 5px; font-size: 12px;
            max-width: 90%; display: none; pointer-events: none;
            z-index: 20;
        }
        h2 { margin-top: 0; font-size: 18px; color: #333; border-bottom: 2px solid #007bff; padding-bottom: 5px;}
        .control-group { margin-bottom: 15px; }
        label { display: block; margin-bottom: 5px; font-weight: bold; font-size: 14px;}
        button {
            width: 100%; padding: 10px; margin-bottom: 5px;
            background-color: #007bff; color: white; border: none;
            border-radius: 4px; cursor: pointer; font-size: 14px;
        }
        button:hover { background-color: #0056b3; }
        button.secondary { background-color: #6c757d; }
        button.secondary:hover { background-color: #545b62; }
        button:disabled { background-color: #ccc; cursor: not-allowed; }
        select { width: 100%; padding: 8px; margin-bottom: 10px; }
        input[type=range] { width: 100%; }
        .value-display { float: right; font-weight: normal; }
        .instruction { font-size: 12px; color: #666; margin-bottom: 10px; }
    </style>
</head>
<body>

<div id="canvas-container"></div>
<div id="error-log"></div>

<div id="ui-panel">
    <h2>立体図形切断シミュレーター v2</h2>
    <p class="instruction">マウス左ドラッグで回転、右ドラッグで移動、ホイールで拡大縮小。</p>

    <div class="control-group">
        <label>1. 図形を選ぶ</label>
        <select id="shape-select">
            <option value="cube">立方体</option>
            <option value="prism">正四角柱</option>
            <option value="pyramid">正四角錐</option>
            <option value="tri_pyramid">正三角錐</option>
            <option value="cylinder">円柱</option>
        </select>
        <button id="reset-btn" class="secondary">図形をリセット</button>
    </div>

    <div class="control-group">
        <label>2. 切断面を調整 (赤色)</label>
        <label>高さ (Y) <span id="val-y" class="value-display">0</span></label>
        <input type="range" id="cut-y" min="-2" max="2" step="0.1" value="0">
        
        <label>回転 (X軸) <span id="val-rx" class="value-display">0°</span></label>
        <input type="range" id="cut-rx" min="0" max="180" step="5" value="0">
        
        <label>回転 (Z軸) <span id="val-rz" class="value-display">0°</span></label>
        <input type="range" id="cut-rz" min="0" max="180" step="5" value="0">
    </div>

    <div class="control-group">
        <label>3. 切断実行</label>
        <button id="cut-btn">✂️ 選択していない側を削除</button>
        <button id="cut-btn-inverse">✂️ 選択側を削除(逆)</button>
    </div>

    <div class="control-group">
        <label>履歴操作</label>
        <button id="undo-btn" class="secondary" disabled>↩️ ひとつ戻る (Undo)</button>
    </div>

    <div class="control-group">
        <label>表示オプション</label>
        <label><input type="checkbox" id="wireframe-check"> ワイヤーフレーム表示</label>
        <label><input type="checkbox" id="ghost-check"> 切断面のガイドを隠す</label>
    </div>
</div>

<script type="importmap">
    {
        "imports": {
            "three": "https://esm.sh/three@0.160.0",
            "three/addons/": "https://esm.sh/three@0.160.0/examples/jsm/",
            "three-bvh-csg": "https://esm.sh/three-bvh-csg@0.0.16?deps=three@0.160.0"
        }
    }
</script>

<script type="module">
    // エラーハンドリング
    window.onerror = function(message, source, lineno, colno, error) {
        const el = document.getElementById('error-log');
        el.style.display = 'block';
        el.innerHTML += `Error: ${message}<br><small>${source}:${lineno}</small><br>`;
    };

    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { SUBTRACTION, Brush, Evaluator } from 'three-bvh-csg';

    // --- シーンのセットアップ ---
    const container = document.getElementById('canvas-container');
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xf0f0f0);

    const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
    camera.position.set(5, 5, 5);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    container.appendChild(renderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;

    // --- ライト ---
    const ambientLight = new THREE.AmbientLight(0x404040, 1.5);
    scene.add(ambientLight);
    const dirLight = new THREE.DirectionalLight(0xffffff, 2);
    dirLight.position.set(5, 10, 7);
    dirLight.castShadow = true;
    scene.add(dirLight);

    // --- グローバル変数 ---
    let currentShapeBrush; // 現在の図形（CSG Brush）
    let cutterBrush;       // 切断用平面（CSG Brush）
    let materialStandard;  // 基本のマテリアル
    let historyStack = []; // Undo用履歴

    const evaluator = new Evaluator();

    // --- マテリアル定義 ---
    materialStandard = new THREE.MeshStandardMaterial({ 
        color: 0x00aaff, 
        roughness: 0.1,
        metalness: 0.1,
        side: THREE.DoubleSide,
        flatShading: false
    });

    // --- 初期化 ---
    init();

    function init() {
        try {
            // グリッドヘルパー
            const gridHelper = new THREE.GridHelper(10, 10);
            scene.add(gridHelper);

            // 軸ヘルパー（XYZがわかるように）
            const axesHelper = new THREE.AxesHelper(5);
            scene.add(axesHelper);

            // 切断用カッターの作成
            createCutter();
            
            // 最初の図形を作成
            createShape('cube');
            
            // カッター位置初期化
            updateCutterTransform();

            animate();
            
        } catch (e) {
            console.error(e);
            document.getElementById('error-log').style.display = 'block';
            document.getElementById('error-log').innerText = "初期化エラー: " + e.message;
        }
    }

    // --- 図形作成 ---
    function createShape(type) {
        let geometry;
        // 以前のジオメトリ定義と同じ
        switch(type) {
            case 'cube': geometry = new THREE.BoxGeometry(2, 2, 2); break;
            case 'prism': geometry = new THREE.BoxGeometry(1.5, 3, 1.5); break;
            case 'pyramid': geometry = new THREE.ConeGeometry(1.5, 2.5, 4); break;
            case 'tri_pyramid': geometry = new THREE.ConeGeometry(1.5, 2.5, 3); break;
            case 'cylinder': geometry = new THREE.CylinderGeometry(1, 1, 3, 32); break;
        }

        if (currentShapeBrush) scene.remove(currentShapeBrush);
        
        currentShapeBrush = new Brush(geometry, materialStandard);
        currentShapeBrush.castShadow = true;
        currentShapeBrush.receiveShadow = true;
        scene.add(currentShapeBrush);
        
        historyStack = [];
        updateUI();
    }

    // --- 切断用カッターの作成 ---
    function createCutter() {
        // 切断ガイドとなる大きなボックス
        const geometry = new THREE.BoxGeometry(10, 10, 10);
        geometry.translate(0, -5, 0); 

        const material = new THREE.MeshBasicMaterial({
            color: 0xff0000,
            opacity: 0.3,
            transparent: true,
            side: THREE.DoubleSide,
            depthWrite: false
        });

        cutterBrush = new Brush(geometry, material);
        scene.add(cutterBrush);
        
        // UIの状態に合わせて表示/非表示
        cutterBrush.visible = !document.getElementById('ghost-check').checked;
    }

    // --- カッターの更新 ---
    function updateCutterTransform() {
        const y = parseFloat(document.getElementById('cut-y').value);
        const rx = parseFloat(document.getElementById('cut-rx').value);
        const rz = parseFloat(document.getElementById('cut-rz').value);

        cutterBrush.position.set(0, y, 0);
        cutterBrush.rotation.set(
            THREE.MathUtils.degToRad(rx),
            0,
            THREE.MathUtils.degToRad(rz)
        );
        cutterBrush.updateMatrixWorld();

        document.getElementById('val-y').innerText = y;
        document.getElementById('val-rx').innerText = rx + "°";
        document.getElementById('val-rz').innerText = rz + "°";
    }

    // --- 切断実行 ---
    function performCut(inverse = false) {
        if (!currentShapeBrush) return;

        const historyGeometry = currentShapeBrush.geometry.clone();
        historyStack.push(historyGeometry);

        if (inverse) {
             cutterBrush.scale.y = -1;
        } else {
             cutterBrush.scale.y = 1;
        }
        cutterBrush.updateMatrixWorld();

        try {
            const resultBrush = evaluator.evaluate(currentShapeBrush, cutterBrush, SUBTRACTION);
            
            scene.remove(currentShapeBrush);
            currentShapeBrush = resultBrush;
            
            // マテリアルの適用
            updateMaterial();

            currentShapeBrush.castShadow = true;
            currentShapeBrush.receiveShadow = true;
            scene.add(currentShapeBrush);

        } catch (err) {
            console.error("Cut failed:", err);
            alert("切断処理に失敗しました。");
        }
        
        cutterBrush.scale.y = 1;
        updateUI();
    }

    // --- Undo ---
    function undo() {
        if (historyStack.length === 0) return;

        const prevGeometry = historyStack.pop();
        scene.remove(currentShapeBrush);
        
        currentShapeBrush = new Brush(prevGeometry, materialStandard);
        updateMaterial();

        currentShapeBrush.castShadow = true;
        currentShapeBrush.receiveShadow = true;
        scene.add(currentShapeBrush);

        updateUI();
    }
    
    function updateMaterial() {
        const isWire = document.getElementById('wireframe-check').checked;
        currentShapeBrush.material = isWire 
            ? new THREE.MeshBasicMaterial({ wireframe: true, color: 0x000000 }) 
            : materialStandard;
    }

    // --- イベントリスナー ---
    document.getElementById('shape-select').addEventListener('change', (e) => createShape(e.target.value));
    document.getElementById('cut-y').addEventListener('input', updateCutterTransform);
    document.getElementById('cut-rx').addEventListener('input', updateCutterTransform);
    document.getElementById('cut-rz').addEventListener('input', updateCutterTransform);
    document.getElementById('cut-btn').addEventListener('click', () => performCut(false));
    document.getElementById('cut-btn-inverse').addEventListener('click', () => performCut(true));
    document.getElementById('undo-btn').addEventListener('click', undo);
    document.getElementById('reset-btn').addEventListener('click', () => createShape(document.getElementById('shape-select').value));
    
    document.getElementById('wireframe-check').addEventListener('change', updateMaterial);
    document.getElementById('ghost-check').addEventListener('change', (e) => {
        if(cutterBrush) cutterBrush.visible = !e.target.checked;
    });

    function updateUI() {
        document.getElementById('undo-btn').disabled = (historyStack.length === 0);
    }

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

    function animate() {
        requestAnimationFrame(animate);
        controls.update();
        renderer.render(scene, camera);
    }
</script>
</body>
</html>
