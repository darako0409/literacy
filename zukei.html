<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>立方体切断デモ</title>
  <style>
    body { background: #20232a; color: #fff; margin: 0; font-family: sans-serif; }
    #canvas-container { width: 100vw; height: 80vh; }
    #controls { padding: 1em; background: #282c34; }
    .btn { margin: 0.2em; }
    .slider-label { margin-right: 8px; }
  </style>
</head>
<body>
  <h2>立方体切断デモ</h2>
  <div id="canvas-container"></div>
  <div id="controls">
    <button class="btn" id="addCutPoint">切断点追加</button>
    <button class="btn" id="clearCutPoints">切断点クリア</button>
    <label class="slider-label">切断スライダー:</label>
    <input type="range" min="0" max="1" step="0.01" value="0.5" id="cutSlider">
    <span id="sliderValue">0.50</span>
  </div>
  <script type="module">
    import * as THREE from "https://cdn.skypack.dev/three@0.150.1";
    import { OrbitControls } from "https://cdn.jsdelivr.net/npm/three@0.150.1/examples/jsm/controls/OrbitControls.js";

    // === 基本セットアップ ===
    const container = document.getElementById("canvas-container");
    const scene = new THREE.Scene();
    scene.background = new THREE.Color("#222");

    const camera = new THREE.PerspectiveCamera(45, container.clientWidth/container.clientHeight, 0.1, 100);
    camera.position.set(2.5, 2.5, 2.5);

    const renderer = new THREE.WebGLRenderer({antialias:true});
    renderer.setSize(container.clientWidth, container.clientHeight);
    container.appendChild(renderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;

    // === 立方体の定義 ===
    const cubeSize = 1;
    const geometry = new THREE.BoxGeometry(cubeSize, cubeSize, cubeSize);
    const material = new THREE.MeshNormalMaterial({transparent:true, opacity:0.3});
    const cube = new THREE.Mesh(geometry, material);
    scene.add(cube);

    // === 辺データ取得 ===
    function getEdgeVertices(geometry) {
      // 立方体の頂点リスト
      const vertices = geometry.attributes.position.array;
      // 立方体の辺（各頂点ペア）
      // BoxGeometryの場合、各頂点は重複しているので、辺を手動で定義
      return [
        [0,1],[1,2],[2,3],[3,0], // 上面
        [4,5],[5,6],[6,7],[7,4], // 下面
        [0,4],[1,5],[2,6],[3,7]  // 側面
      ].map(([a,b]) => [geometry.attributes.position.array.slice(a*3,a*3+3), geometry.attributes.position.array.slice(b*3,b*3+3)]);
    }
    const edges = getEdgeVertices(geometry);

    // === 辺の可視化 ===
    const edgeGroup = new THREE.Group();
    edges.forEach(([v1,v2]) => {
      const points = [new THREE.Vector3(...v1), new THREE.Vector3(...v2)];
      const edgeGeo = new THREE.BufferGeometry().setFromPoints(points);
      const edgeMat = new THREE.LineBasicMaterial({color:0xffffff});
      const line = new THREE.Line(edgeGeo, edgeMat);
      edgeGroup.add(line);
    });
    scene.add(edgeGroup);

    // === 切断点データと可視化 ===
    let cutPoints = []; // {edgeIdx, t:0~1}
    const cutPointGroup = new THREE.Group();
    scene.add(cutPointGroup);

    function updateCutPoints() {
      cutPointGroup.clear();
      cutPoints.forEach(pt => {
        const [v1, v2] = edges[pt.edgeIdx];
        const p = [
          v1[0] + (v2[0] - v1[0]) * pt.t,
          v1[1] + (v2[1] - v1[1]) * pt.t,
          v1[2] + (v2[2] - v1[2]) * pt.t
        ];
        const mesh = new THREE.Mesh(
          new THREE.SphereGeometry(0.04, 16, 16),
          new THREE.MeshBasicMaterial({color:0xff0000})
        );
        mesh.position.set(...p);
        cutPointGroup.add(mesh);
      });
    }

    // === 切断平面の可視化（スライダーに応じて） ===
    let cutPlane = null;
    function updateCutPlane() {
      if(cutPlane) scene.remove(cutPlane);

      // スライダー値で立方体内に平面を作る
      const t = parseFloat(document.getElementById('cutSlider').value); // 0~1
      const planeGeo = new THREE.PlaneGeometry(cubeSize, cubeSize);
      const planeMat = new THREE.MeshBasicMaterial({color:0x00ff00, side:THREE.DoubleSide, transparent:true, opacity:0.2});
      cutPlane = new THREE.Mesh(planeGeo, planeMat);
      cutPlane.position.set(0, t*cubeSize - cubeSize/2, 0); // Y方向にスライド
      cutPlane.rotation.x = Math.PI/2;
      scene.add(cutPlane);
    }

    // === 辺クリックで切断点追加 ===
    renderer.domElement.addEventListener('pointerdown', e => {
      const mouse = new THREE.Vector2(
        (e.offsetX / renderer.domElement.width) * 2 - 1,
        -(e.offsetY / renderer.domElement.height) * 2 + 1
      );
      const raycaster = new THREE.Raycaster();
      raycaster.setFromCamera(mouse, camera);
      let minDist = Infinity, minIdx = null, minT = null;
      edges.forEach(([v1,v2], i) => {
        // 辺を線分として最短距離計算
        const p1 = new THREE.Vector3(...v1), p2 = new THREE.Vector3(...v2);
        const intersect = closestPointOnLine(raycaster.ray, p1, p2);
        const dist = intersect.point.distanceTo(raycaster.ray.origin);
        if(dist < minDist && dist < 0.1) { // 近ければ選択
          minDist = dist; minIdx = i; minT = intersect.t;
        }
      });
      if(minIdx !== null) {
        cutPoints.push({edgeIdx:minIdx, t:minT});
        updateCutPoints();
      }
    });
    function closestPointOnLine(ray, p1, p2) {
      // 線分p1-p2上にrayから最短点
      const v = new THREE.Vector3().subVectors(p2, p1);
      const w = new THREE.Vector3().subVectors(ray.origin, p1);
      const t = v.dot(w) / v.lengthSq();
      return {point: new THREE.Vector3().addVectors(p1, v.multiplyScalar(t)), t:Math.max(0, Math.min(1, t))};
    }

    // === UIイベント ===
    document.getElementById('addCutPoint').onclick = () => {
      // ランダムな辺に切断点追加（デモ用）
      const edgeIdx = Math.floor(Math.random()*edges.length);
      const t = Math.random();
      cutPoints.push({edgeIdx, t});
      updateCutPoints();
    };
    document.getElementById('clearCutPoints').onclick = () => {
      cutPoints = [];
      updateCutPoints();
    };
    document.getElementById('cutSlider').oninput = e => {
      document.getElementById('sliderValue').textContent = e.target.value;
      updateCutPlane();
    };
    updateCutPlane();

    // === レンダリングループ ===
    function animate() {
      controls.update();
      renderer.render(scene, camera);
      requestAnimationFrame(animate);
    }
    animate();

    // === 画面サイズ対応 ===
    window.addEventListener("resize", () => {
      camera.aspect = container.clientWidth/container.clientHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(container.clientWidth, container.clientHeight);
    });
  </script>
</body>
</html>
