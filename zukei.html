<!DOCTYPE html>
import React, { useRef, useEffect, useState, useCallback } from 'react';
import * as THREE from 'three';
import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';
// Main App component for the cube cutting simulation
const App = () => {
  // Refs for the canvas mount point and Three.js objects
  const mountRef = useRef(null);
  const rendererRef = useRef(null);
  const sceneRef = useRef(null);
  const cameraRef = useRef(null);
  const controlsRef = useRef(null);

  // State to manage the application's flow
  const [selectedPoints, setSelectedPoints] = useState([]);
  const [cutFace, setCutFace] = useState(null);
  const [message, setMessage] = useState('立方体の頂点を3つ選択してください。');

  // Define the 8 vertices of the cube
  const vertices = [
    new THREE.Vector3(-1, -1, -1), // 0
    new THREE.Vector3(1, -1, -1),  // 1
    new THREE.Vector3(1, 1, -1),   // 2
    new THREE.Vector3(-1, 1, -1),  // 3
    new THREE.Vector3(-1, -1, 1),  // 4
    new THREE.Vector3(1, -1, 1),   // 5
    new THREE.Vector3(1, 1, 1),    // 6
    new THREE.Vector3(-1, 1, 1)    // 7
  ];

  // Define the 12 edges of the cube using vertex indices
  const edges = [
    [0, 1], [1, 2], [2, 3], [3, 0], // Bottom face
    [4, 5], [5, 6], [6, 7], [7, 4], // Top face
    [0, 4], [1, 5], [2, 6], [3, 7]  // Vertical edges
  ].map(pair => ({ start: vertices[pair[0]], end: vertices[pair[1]] }));

  // Initialize the 3D scene, camera, renderer, and controls
  useEffect(() => {
    const currentMount = mountRef.current;
    if (!currentMount) return;

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xf0f0f0);
    sceneRef.current = scene;

    const camera = new THREE.PerspectiveCamera(75, currentMount.clientWidth / currentMount.clientHeight, 0.1, 1000);
    camera.position.set(2, 2, 5);
    cameraRef.current = camera;

    const renderer = new THREE.WebGLRenderer({ antialiasing: true });
    renderer.setSize(currentMount.clientWidth, currentMount.clientHeight);
    rendererRef.current = renderer;
    currentMount.appendChild(renderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);
    controlsRef.current = controls;

    // Add lighting to the scene
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
    scene.add(ambientLight);
    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
    directionalLight.position.set(0, 1, 1);
    scene.add(directionalLight);

    // Create a wireframe cube
    const cubeGeometry = new THREE.BoxGeometry(2, 2, 2);
    const cubeMaterial = new THREE.MeshBasicMaterial({ color: 0xcccccc, wireframe: true, transparent: true, opacity: 0.2 });
    const cube = new THREE.Mesh(cubeGeometry, cubeMaterial);
    scene.add(cube);

    // Create interactive spheres for each vertex
    const pointGeometry = new THREE.SphereGeometry(0.1, 32, 32);
    const pointMaterial = new THREE.MeshBasicMaterial({ color: 0x333333 });
    vertices.forEach((v, index) => {
      const point = new THREE.Mesh(pointGeometry, pointMaterial);
      point.position.copy(v);
      point.userData.isVertex = true;
      point.userData.originalColor = new THREE.Color(0x333333);
      point.userData.index = index;
      scene.add(point);
    });

    // Create a raycaster for detecting clicks on the spheres
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();

    const onMouseClick = (event) => {
      event.preventDefault();

      // Normalize mouse coordinates to Three.js NDC
      const rect = renderer.domElement.getBoundingClientRect();
      mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
      mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

      raycaster.setFromCamera(mouse, camera);

      const intersects = raycaster.intersectObjects(scene.children.filter(c => c.userData.isVertex));

      if (intersects.length > 0) {
        const intersectedPoint = intersects[0].object;
        handlePointClick(intersectedPoint);
      }
    };

    // Add event listener for mouse clicks
    renderer.domElement.addEventListener('click', onMouseClick, false);

    // The animation loop
    const animate = () => {
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    };

    animate();

    // Clean up function
    return () => {
      if (renderer.domElement) {
        currentMount.removeChild(renderer.domElement);
        renderer.domElement.removeEventListener('click', onMouseClick, false);
      }
      scene.remove(cube);
      scene.children.forEach(child => {
        if (child.userData.isVertex) {
          scene.remove(child);
        }
      });
      controls.dispose();
    };
  }, []);

  // Function to handle vertex clicks
  const handlePointClick = useCallback((pointMesh) => {
    // Prevent adding the same point multiple times
    if (selectedPoints.some(p => p.equals(pointMesh.position))) {
      return;
    }

    if (selectedPoints.length < 3) {
      const newPoints = [...selectedPoints, pointMesh.position.clone()];
      setSelectedPoints(newPoints);
      pointMesh.material.color.set(0xff0000); // Change color of selected point

      if (newPoints.length === 3) {
        setMessage('切断面が作成されました！');
        calculateCutFace(newPoints);
      } else {
        setMessage(`頂点をあと${3 - newPoints.length}つ選択してください。`);
      }
    }
  }, [selectedPoints]);

  // Function to calculate and draw the cut face
  const calculateCutFace = useCallback((points) => {
    // If the cut face already exists, remove it
    if (cutFace) {
      sceneRef.current.remove(cutFace);
      setCutFace(null);
    }

    const [p1, p2, p3] = points;
    const scene = sceneRef.current;

    // Create a plane from the three selected points
    const v1 = new THREE.Vector3().subVectors(p2, p1);
    const v2 = new THREE.Vector3().subVectors(p3, p1);
    const normal = new THREE.Vector3().crossVectors(v1, v2).normalize();
    const plane = new THREE.Plane().setFromNormalAndCoplanarPoint(normal, p1);

    // Find all intersection points with the cube's edges
    const intersectionPoints = [];
    edges.forEach(edge => {
      const line = new THREE.Line3(edge.start, edge.end);
      const intersectionPoint = new THREE.Vector3();
      plane.intersectLine(line, intersectionPoint);

      // Check if the intersection point lies on the line segment
      if (intersectionPoint && intersectionPoint.distanceTo(edge.start) < edge.start.distanceTo(edge.end) + 0.001 &&
          intersectionPoint.distanceTo(edge.end) < edge.start.distanceTo(edge.end) + 0.001) {
        
        // Check if the point is already in the list to avoid duplicates
        const isDuplicate = intersectionPoints.some(p => p.distanceTo(intersectionPoint) < 0.001);
        if (!isDuplicate) {
          intersectionPoints.push(intersectionPoint);
        }
      }
    });

    // We expect at least 3 intersection points for a valid polygon
    if (intersectionPoints.length < 3) {
      setMessage('切断面を作成できませんでした。別の頂点を選択してください。');
      return;
    }

    // Sort the points to form a convex polygon
    const center = new THREE.Vector3();
    intersectionPoints.forEach(p => center.add(p));
    center.divideScalar(intersectionPoints.length);

    intersectionPoints.sort((a, b) => {
      return -Math.atan2(a.y - center.y, a.x - center.x) + Math.atan2(b.y - center.y, b.x - center.x);
    });

    // Create a shape from the sorted points
    const shape = new THREE.Shape(intersectionPoints.map(p => new THREE.Vector2(p.x, p.y)));
    const shapeGeometry = new THREE.ShapeGeometry(shape);
    const cutFaceMaterial = new THREE.MeshPhongMaterial({ color: 0x33ff33, transparent: true, opacity: 0.5, side: THREE.DoubleSide });
    const newCutFace = new THREE.Mesh(shapeGeometry, cutFaceMaterial);
    
    // Position and orient the cut face to match the plane
    const quaternion = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 0, 1), normal);
    newCutFace.position.copy(center);
    newCutFace.setRotationFromQuaternion(quaternion);
    
    scene.add(newCutFace);
    setCutFace(newCutFace);

  }, [cutFace, edges]);

  // Function to reset the simulation to its initial state
  const resetSimulation = () => {
    if (cutFace) {
      sceneRef.current.remove(cutFace);
      setCutFace(null);
    }
    setSelectedPoints([]);
    sceneRef.current.children.forEach(child => {
      if (child.userData.isVertex) {
        child.material.color.set(child.userData.originalColor);
      }
    });
    setMessage('立方体の頂点を3つ選択してください。');
  };

  return (
    <div className="flex flex-col h-screen bg-gray-100 font-sans antialiased">
      <div className="flex-grow relative overflow-hidden" ref={mountRef}></div>
      <div className="p-4 bg-white shadow-lg flex items-center justify-between">
        <h1 className="text-xl font-bold text-gray-800">
          {message}
        </h1>
        <button
          onClick={resetSimulation}
          className="px-6 py-2 bg-red-500 text-white font-semibold rounded-full shadow-md hover:bg-red-600 transition-colors duration-200"
        >
          リセット
        </button>
      </div>
    </div>
  );
};

export default App;
