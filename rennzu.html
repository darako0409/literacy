<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>レンズによる像シミュレーション</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f4f8;
            color: #1a202c;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            flex-direction: column;
        }
        canvas {
            border: 2px solid #e2e8f0;
            background-color: #ffffff;
            touch-action: none;
        }
        .message-box {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: #4a5568;
            color: white;
            padding: 1rem;
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1), 0 1px 3px rgba(0, 0, 0, 0.08);
            z-index: 100;
        }
    </style>
</head>
<body class="p-4">

    <div class="container mx-auto p-6 bg-white rounded-xl shadow-lg border border-gray-200">
        <h1 class="text-3xl font-bold text-center text-gray-800 mb-6">レンズによる像シミュレーション</h1>

        <div class="mb-4 flex flex-col sm:flex-row items-center justify-center space-y-4 sm:space-y-0 sm:space-x-4">
            <div class="flex items-center space-x-2">
                <label for="lensType" class="text-sm font-medium text-gray-700">レンズの種類:</label>
                <select id="lensType" class="form-select rounded-md border-gray-300 shadow-sm focus:border-indigo-300 focus:ring focus:ring-indigo-200 focus:ring-opacity-50">
                    <option value="convex">凸レンズ</option>
                    <option value="concave">凹レンズ</option>
                </select>
            </div>

            <div class="flex items-center space-x-2">
                <label for="focalLength" class="text-sm font-medium text-gray-700">焦点距離 (px):</label>
                <input type="number" id="focalLength" value="100" min="50" max="200" class="form-input rounded-md border-gray-300 shadow-sm w-24">
            </div>

            <div class="flex items-center space-x-2">
                <label for="objectHeight" class="text-sm font-medium text-gray-700">物体の高さ (px):</label>
                <input type="number" id="objectHeight" value="40" min="10" max="100" class="form-input rounded-md border-gray-300 shadow-sm w-24">
            </div>
        </div>

        <div class="w-full flex items-center justify-center mb-6">
            <canvas id="lensCanvas" class="w-full max-w-2xl aspect-video rounded-xl"></canvas>
        </div>
        
        <!-- 像の性質を表示するパネル -->
        <div id="imageProperties" class="bg-gray-100 p-4 rounded-lg shadow-inner mt-4 w-full max-w-2xl text-center text-gray-800">
            <h3 class="text-lg font-semibold mb-2">像の性質</h3>
            <div class="flex justify-center flex-wrap space-x-4 sm:space-x-8">
                <p>種類: <span id="imageType" class="font-bold"></span></p>
                <p>向き: <span id="imageOrientation" class="font-bold"></span></p>
                <p>大きさ: <span id="imageSize" class="font-bold"></span></p>
            </div>
        </div>

        <div class="text-center text-sm text-gray-600 space-y-2 mt-4">
            <p><strong>操作方法:</strong></p>
            <ul class="list-disc list-inside space-y-1 inline-block text-left">
                <li><span class="font-bold">物体:</span> マウスまたは指でドラッグして左右に動かすことができます。</li>
                <li><span class="font-bold">焦点 (Fと表示):</span> マウスまたは指でドラッグして左右に動かすことができます。</li>
                <li><span class="font-bold">レンズの種類:</span> ドロップダウンメニューで凸レンズと凹レンズを切り替えることができます。</li>
            </ul>
        </div>
    </div>

    <div id="messageBox" class="hidden message-box"></div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const canvas = document.getElementById('lensCanvas');
            const ctx = canvas.getContext('2d');
            const lensTypeSelect = document.getElementById('lensType');
            const focalLengthInput = document.getElementById('focalLength');
            const objectHeightInput = document.getElementById('objectHeight');
            const messageBox = document.getElementById('messageBox');
            const imageTypeSpan = document.getElementById('imageType');
            const imageOrientationSpan = document.getElementById('imageOrientation');
            const imageSizeSpan = document.getElementById('imageSize');

            // --- Canvas and Simulation State ---
            let isDragging = false;
            let dragTarget = null; // 'object' or 'focalPoint'
            let initialMouseX;
            let initialObjectX;
            let initialFocalLength;
            let dragFocalSide = null; // 'left' or 'right'

            const simState = {
                lensType: 'convex', // 'convex' or 'concave'
                focalLength: 100, // f
                objectX: -200, // object distance from lens center (p)
                objectHeight: 40 // height of the object
            };

            const center = {
                x: 0,
                y: 0
            };

            // --- UI Handlers ---
            lensTypeSelect.addEventListener('change', (e) => {
                simState.lensType = e.target.value;
                if (simState.lensType === 'concave') {
                    simState.focalLength = -Math.abs(simState.focalLength);
                } else {
                    simState.focalLength = Math.abs(simState.focalLength);
                }
                focalLengthInput.value = Math.abs(simState.focalLength);
                draw();
            });

            focalLengthInput.addEventListener('change', (e) => {
                let f = parseFloat(e.target.value);
                if (simState.lensType === 'concave') {
                    simState.focalLength = -Math.abs(f);
                } else {
                    simState.focalLength = Math.abs(f);
                }
                draw();
            });

            objectHeightInput.addEventListener('change', (e) => {
                simState.objectHeight = parseFloat(e.target.value);
                draw();
            });

            // --- Utility Functions ---
            function showMessage(msg, duration = 3000) {
                messageBox.textContent = msg;
                messageBox.classList.remove('hidden');
                setTimeout(() => {
                    messageBox.classList.add('hidden');
                }, duration);
            }

            function scaleCanvas() {
                const container = canvas.parentElement;
                const containerWidth = container.clientWidth;
                const ratio = window.devicePixelRatio || 1;

                // Set canvas resolution for crisp drawing
                canvas.width = containerWidth * ratio;
                canvas.height = (containerWidth * 0.5625) * ratio; // 16:9 aspect ratio
                ctx.scale(ratio, ratio);

                // Update internal center position
                center.x = canvas.width / (2 * ratio);
                center.y = canvas.height / (2 * ratio);

                draw();
            }

            // A helper function to draw an arrow shape
            function drawArrow(fromX, fromY, toX, toY, color = '#1a202c', lineDash = []) {
                ctx.strokeStyle = color;
                ctx.fillStyle = color;
                ctx.lineWidth = 2;
                ctx.setLineDash(lineDash);

                const headlen = 10;
                const dx = toX - fromX;
                const dy = toY - fromY;
                const angle = Math.atan2(dy, dx);

                ctx.beginPath();
                ctx.moveTo(fromX, fromY);
                ctx.lineTo(toX, toY);
                ctx.stroke();

                ctx.beginPath();
                ctx.moveTo(toX, toY);
                ctx.lineTo(toX - headlen * Math.cos(angle - Math.PI / 6), toY - headlen * Math.sin(angle - Math.PI / 6));
                ctx.moveTo(toX, toY);
                ctx.lineTo(toX - headlen * Math.cos(angle + Math.PI / 6), toY - headlen * Math.sin(angle + Math.PI / 6));
                ctx.stroke();

                ctx.setLineDash([]);
            }

            // --- Main Drawing Function ---
            function draw() {
                // Clear canvas and set background
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Optical axis
                ctx.strokeStyle = '#cbd5e0';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(0, center.y);
                ctx.lineTo(canvas.width, center.y);
                ctx.stroke();

                // Lens
                ctx.strokeStyle = '#60a5fa';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(center.x, 0);
                ctx.lineTo(center.x, canvas.height);
                ctx.stroke();

                // Object (Arrow)
                const objectTipX = center.x + simState.objectX;
                const objectBaseY = center.y;
                const objectTipY = center.y - simState.objectHeight;
                drawArrow(objectTipX, objectBaseY, objectTipX, objectTipY, '#1a202c');
                ctx.fillStyle = '#1a202c';
                ctx.font = '14px Inter';
                ctx.fillText('物体', objectTipX - 15, objectTipY - 10);

                // Focal points
                const F = Math.abs(simState.focalLength);
                const F1x = center.x - F;
                const F2x = center.x + F;
                
                // 2F points
                const twoF1x = center.x - 2 * F;
                const twoF2x = center.x + 2 * F;


                ctx.fillStyle = '#ef4444';
                ctx.beginPath();
                ctx.arc(F1x, center.y, 4, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(F2x, center.y, 4, 0, Math.PI * 2);
                ctx.fill();

                ctx.fillStyle = '#f97316';
                ctx.beginPath();
                ctx.arc(twoF1x, center.y, 4, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(twoF2x, center.y, 4, 0, Math.PI * 2);
                ctx.fill();

                ctx.font = '12px Inter';
                ctx.fillStyle = '#ef4444';
                ctx.fillText('F', F1x - 10, center.y - 10);
                ctx.fillText('F', F2x + 6, center.y - 10);

                ctx.fillStyle = '#f97316';
                ctx.fillText('2F', twoF1x - 15, center.y - 10);
                ctx.fillText('2F', twoF2x + 6, center.y - 10);

                // --- Ray Tracing Logic ---
                const rayStart = { x: objectTipX, y: objectTipY };

                // Calculate image properties using lens formula
                let imageX = Infinity;
                let imageY = Infinity;
                let isReal = false;
                let isUpright = false;
                let imageSize = '不明';

                if (simState.objectX !== 0) {
                     const p = -simState.objectX; // object distance from lens
                     const f = simState.lensType === 'convex' ? F : -F; 
                     const q = (p * f) / (p - f); 
                     
                     isReal = (q > 0);
                     imageX = center.x + q;
                     
                     const M = -q / p; 
                     imageY = center.y - simState.objectHeight * M;
                     
                     isUpright = (M > 0);

                     if (Math.abs(M) > 1) {
                         imageSize = '大きい';
                     } else if (Math.abs(M) < 1) {
                         imageSize = '小さい';
                     } else {
                         imageSize = '同じ';
                     }
                } else {
                     imageX = center.x;
                     imageY = center.y - simState.objectHeight;
                }
                
                // Ray 1: Parallel to axis
                const ray1LensPoint = { x: center.x, y: rayStart.y };
                ctx.strokeStyle = '#22c55e'; // green
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(rayStart.x, rayStart.y);
                ctx.lineTo(ray1LensPoint.x, ray1LensPoint.y);
                ctx.stroke();
                
                // Draw refracted/extended Ray 1
                ctx.beginPath();
                ctx.moveTo(ray1LensPoint.x, ray1LensPoint.y);
                if (simState.lensType === 'convex' && isReal) {
                    ctx.lineTo(imageX, imageY);
                } else if (simState.lensType === 'convex' && !isReal) { // Convex virtual image case
                    const rayEnd = {
                        x: canvas.width,
                        y: (ray1LensPoint.y - F2x * center.y / F2x) / (ray1LensPoint.x - F2x) * (canvas.width - ray1LensPoint.x) + ray1LensPoint.y
                    };
                    ctx.lineTo(rayEnd.x, rayEnd.y);
                    ctx.stroke();
                    ctx.strokeStyle = '#cbd5e0';
                    ctx.setLineDash([5, 5]);
                    ctx.beginPath();
                    ctx.moveTo(ray1LensPoint.x, ray1LensPoint.y);
                    ctx.lineTo(imageX, imageY);
                } else if (simState.lensType === 'concave') { // Concave lens (always virtual)
                     const m = (ray1LensPoint.y - center.y) / (ray1LensPoint.x - F1x);
                     const b = ray1LensPoint.y - m * ray1LensPoint.x;
                     ctx.lineTo(canvas.width, m * canvas.width + b);
                     ctx.stroke();
                     ctx.strokeStyle = '#cbd5e0';
                     ctx.setLineDash([5, 5]);
                     ctx.beginPath();
                     ctx.moveTo(ray1LensPoint.x, ray1LensPoint.y);
                     ctx.lineTo(imageX, imageY);
                }
                ctx.stroke();
                ctx.setLineDash([]);
                
                // Ray 2: Through lens center
                ctx.strokeStyle = '#ef4444'; // red
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(rayStart.x, rayStart.y);
                if (isReal) {
                    ctx.lineTo(imageX, imageY);
                } else {
                    ctx.strokeStyle = '#ef4444';
                    ctx.beginPath();
                    const m = (rayStart.y - center.y) / (rayStart.x - center.x);
                    const b = rayStart.y - m * rayStart.x;
                    ctx.moveTo(rayStart.x, rayStart.y);
                    ctx.lineTo(canvas.width, m * canvas.width + b);
                    ctx.stroke();
                    ctx.setLineDash([5, 5]);
                    ctx.beginPath();
                    ctx.moveTo(rayStart.x, rayStart.y);
                    ctx.lineTo(imageX, imageY);
                }
                ctx.stroke();
                ctx.setLineDash([]);

                // Ray 3: Through near focal point or towards far focal point, refracts parallel to axis
                ctx.strokeStyle = '#3b82f6'; // blue
                ctx.lineWidth = 1;
                
                if (simState.lensType === 'convex') {
                    if (isReal) {
                        const ray3FocalX = F1x;
                        const m3 = (rayStart.y - center.y) / (rayStart.x - ray3FocalX);
                        const yOnLens = m3 * (center.x - ray3FocalX) + center.y;
                        ctx.beginPath();
                        ctx.moveTo(rayStart.x, rayStart.y);
                        ctx.lineTo(center.x, yOnLens);
                        ctx.stroke();
                        ctx.beginPath();
                        ctx.moveTo(center.x, yOnLens);
                        ctx.lineTo(canvas.width, yOnLens);
                    } else { // virtual
                        ctx.strokeStyle = '#3b82f6';
                        const yOnLens = (rayStart.y - center.y) / (rayStart.x - imageX) * (center.x - imageX) + center.y;
                        ctx.beginPath();
                        ctx.moveTo(rayStart.x, rayStart.y);
                        ctx.lineTo(canvas.width, yOnLens);
                        ctx.stroke();
                        ctx.strokeStyle = '#cbd5e0';
                        ctx.setLineDash([5, 5]);
                        ctx.beginPath();
                        ctx.moveTo(center.x, yOnLens);
                        ctx.lineTo(imageX, imageY);
                    }
                } else if (simState.lensType === 'concave') {
                     const ray3FocalX = F2x;
                     const m3 = (center.y - rayStart.y) / (ray3FocalX - rayStart.x);
                     const yOnLens = rayStart.y + m3 * (center.x - rayStart.x);
                     
                     ctx.beginPath();
                     ctx.moveTo(rayStart.x, rayStart.y);
                     ctx.lineTo(center.x, yOnLens);
                     ctx.stroke();

                     ctx.beginPath();
                     ctx.moveTo(center.x, yOnLens);
                     ctx.lineTo(canvas.width, yOnLens);
                     ctx.stroke();

                     ctx.strokeStyle = '#cbd5e0';
                     ctx.setLineDash([5, 5]);
                     ctx.beginPath();
                     ctx.moveTo(center.x, yOnLens);
                     ctx.lineTo(ray3FocalX, center.y);
                }
                ctx.stroke();
                ctx.setLineDash([]);


                // Draw the image
                const imageBase = { x: imageX, y: center.y };
                const imageTip = { x: imageX, y: imageY };
                
                if (simState.objectX !== 0 && !isNaN(imageX) && isFinite(imageX)) {
                    ctx.strokeStyle = '#9ca3af';
                    ctx.lineWidth = 2;
                    ctx.fillStyle = '#9ca3af';
                    drawArrow(imageBase.x, imageBase.y, imageTip.x, imageTip.y, '#9ca3af', isReal ? [] : [5, 5]);
                    ctx.fillText('像', imageX - 5, imageTip.y - 10);
                }


                // Update properties text
                imageTypeSpan.textContent = isReal ? '実像' : '虚像';
                imageOrientationSpan.textContent = isUpright ? '正立（上下逆ではない）' : '倒立（上下逆）';
                imageSizeSpan.textContent = imageSize;
            }

            // --- Drag and Drop Logic ---
            function getCanvasCoordinates(e) {
                const rect = canvas.getBoundingClientRect();
                const clientX = e.clientX || (e.touches ? e.touches[0].clientX : 0);
                const clientY = e.clientY || (e.touches ? e.touches[0].clientY : 0);
                return {
                    x: clientX - rect.left,
                    y: clientY - rect.top
                };
            }

            function handleStart(e) {
                e.preventDefault();
                const pos = getCanvasCoordinates(e);
                const objectX = center.x + simState.objectX;
                const F = Math.abs(simState.focalLength);
                const F1x = center.x - F;
                const F2x = center.x + F;

                // Check if user clicked on the object
                if (Math.abs(pos.x - objectX) < 15 && Math.abs(pos.y - center.y) < Math.abs(simState.objectHeight)) {
                    isDragging = true;
                    dragTarget = 'object';
                    initialMouseX = pos.x;
                    initialObjectX = simState.objectX;
                }
                
                // Check if user clicked on a focal point
                if (Math.abs(pos.x - F1x) < 15 && Math.abs(pos.y - center.y) < 15) {
                    isDragging = true;
                    dragTarget = 'focalPoint';
                    dragFocalSide = 'left';
                    initialMouseX = pos.x;
                    initialFocalLength = Math.abs(simState.focalLength);
                } else if (Math.abs(pos.x - F2x) < 15 && Math.abs(pos.y - center.y) < 15) {
                    isDragging = true;
                    dragTarget = 'focalPoint';
                    dragFocalSide = 'right';
                    initialMouseX = pos.x;
                    initialFocalLength = Math.abs(simState.focalLength);
                }
            }

            function handleMove(e) {
                if (!isDragging) return;
                e.preventDefault();
                const pos = getCanvasCoordinates(e);
                const dx = pos.x - initialMouseX;

                if (dragTarget === 'object') {
                    const newObjectX = initialObjectX + dx;
                    if (newObjectX < -1) {
                        simState.objectX = newObjectX;
                    } else {
                         showMessage("物体はレンズを通過できません。");
                         simState.objectX = -1;
                    }
                } else if (dragTarget === 'focalPoint') {
                    let newAbsFocalLength;
                    if (dragFocalSide === 'left') {
                        newAbsFocalLength = initialFocalLength - dx;
                    } else { // 'right'
                        newAbsFocalLength = initialFocalLength + dx;
                    }
                    
                    if (newAbsFocalLength < 50) {
                        newAbsFocalLength = 50;
                        showMessage("焦点距離が短すぎます。");
                    } else if (newAbsFocalLength > 200) {
                        newAbsFocalLength = 200;
                        showMessage("焦点距離が長すぎます。");
                    }
                    
                    if (simState.lensType === 'concave') {
                        simState.focalLength = -newAbsFocalLength;
                    } else {
                        simState.focalLength = newAbsFocalLength;
                    }
                    focalLengthInput.value = newAbsFocalLength;
                }
                draw();
            }

            function handleEnd(e) {
                isDragging = false;
                dragTarget = null;
            }

            // Add event listeners for both mouse and touch events
            canvas.addEventListener('mousedown', handleStart);
            canvas.addEventListener('mousemove', handleMove);
            canvas.addEventListener('mouseup', handleEnd);
            canvas.addEventListener('mouseleave', handleEnd);

            canvas.addEventListener('touchstart', handleStart);
            canvas.addEventListener('touchmove', handleMove);
            canvas.addEventListener('touchend', handleEnd);

            // Initial setup
            scaleCanvas();
            window.addEventListener('resize', scaleCanvas);
        });
    </script>
</body>
</html>
